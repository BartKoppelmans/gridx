<html>
<head>
<title>Gridx Tests</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
<style>.feature_id {color: red; padding-right: 50px;}</style>
</head>
<body>
<div><span class="feature_id">core-1</span>header单元格与对应列中的body单元格始终保持对齐</div>
<a href="core-2.html" target="_blank"><span class="feature_id">core-2</span>[header] 当有水平滚动条时，header.refresh应该保持refresh前后的header scrollLeft一致</a><br/>
<a href="core-3.html" target="_blank"><span class="feature_id">core-3</span>[header] 设置header.hidden之后，header.refresh应该相应的去显示或者隐藏header</a><br/>
<div><span class="feature_id">core-4</span>[header] getHeaderNode在columnId不存在时返回undefined，不应产生错误</div>
<a href="core_columnwidth.html" target="_blank"><span class="feature_id">core-5</span>非auto非百分比的固定列宽直接赋值给单元格的style.width，不包含padding和border</a><br/>
<a href="core_columnwidth.html" target="_blank"><span class="feature_id">core-6</span>百分比列宽按body部分宽度为100%计算，包含padding和border，换算成px值后赋值给单元格，因此若所有列都是百分比列宽，且列宽之和等于100%，则恰好不出现横向滚动条</a><br/>
<a href="core_columnwidth.html" target="_blank"><span class="feature_id">core-7</span>当固定列宽和百分比列宽的总和小于body总宽度时，auto列平均分配剩余宽度</a><br/>
<a href="core_columnwidth.html" target="_blank"><span class="feature_id">core-8</span>当固定列宽和百分比列宽的总和大于body总宽度时，auto列为默认列宽columnWidthDefault</a><br/>
<a href="core_columnwidth.html" target="_blank"><span class="feature_id">core-9</span>当columnWidthAutoResize为true，只接受百分比列宽和auto列宽，固定列宽被强制替换为auto列宽，所有列宽直接赋值给单元格，因此当grid宽度变化时列宽可自动变化</a><br/>
<div><span class="feature_id">core-10</span>纵向滚动条的宽度不包含在body宽度内，其高度等于body高度</div>
<a href="core-11.html" target="_blank"><span class="feature_id">core-11</span>若初始行数不足以填满整个body区域，则不显示纵向滚动条</a><br/>
<a href="core-12.html" target="_blank"><span class="feature_id">core-12</span>若初始行数超出body区域，则显示纵向滚动条</a><br/>
<a href="core_autoHideVScroller.html" target="_blank"><span class="feature_id">core-13</span>若初始有纵向滚动条，当可显示行数不足以填满整个body区域时，纵向滚动条消失，且body宽度增大以适应grid宽度，所有百分比列宽和auto列宽重新计算</a><br/>
<a href="core_autoHideVScroller.html" target="_blank"><span class="feature_id">core-14</span>若初始无纵向滚动条，当可显示行数超出body区域时，纵向滚动条出现，且body宽度减小以适应grid宽度，所有百分比列宽和auto列宽重新计算</a><br/>
<div><span class="feature_id">core-15</span>横向滚动条的高度不包含在body高度内，其宽度等于body宽度</div>
<a href="core-16.html" target="_blank"><span class="feature_id">core-16</span>若列不足以填满整个body区域，则不显示横向滚动条</a><br/>
<a href="core-17.html" target="_blank"><span class="feature_id">core-17</span>若列超出body区域，则显示横向滚动条</a><br/>
<div><span class="feature_id">core-18</span>初始创建grid时，若headerHidden为true，不显示header</div>
<a href="core-19-21.html" target="_blank"><span class="feature_id">core-19</span>当鼠标悬浮在某header单元格时，高亮该header单元格</a><br/>
<a href="core-19-21.html" target="_blank"><span class="feature_id">core-20</span>当鼠标悬浮在某一行时，高亮该行</a><br/>
<a href="core-19-21.html" target="_blank"><span class="feature_id">core-21</span>当bodyRowHoverEffect为false时，不高亮鼠标经过的行</a><br/>
<a href="core-22.html" target="_blank"><span class="feature_id">core-22</span>[bodyLoadingInfo] 在body render好之前body应该显示loadingInfo</a><br/>
<a href="core-23-25.html" target="_blank"><span class="feature_id">core-23</span>[bodyEmptyInfo] 如果gridx行数为0，body显示empty info，如果此时向store中添加行，body应该不显示empty info，而显示行</a><br/>
<a href="core-23-25.html" target="_blank"><span class="feature_id">core-24</span>[bodyEmptyInfo] 如果gridx行数不为0，删除store中数据行直到为0，此时body应该显示empty info</a><br/>
<a href="core-23-25.html" target="_blank"><span class="feature_id">core-25</span>[bodyEmptyInfo]   如果gridx行数不为0，为grid设置一个全新的空store， 此时body应该显示empty info</a><br/>
<a href="core-26-27.html" target="_blank"><span class="feature_id">core-26</span>当bodyStuffEmptyCell为true时， 某一行没有任何数据时，自动在单元格内填入空格以保证该行有正常高度</a><br/>
<a href="core-26-27.html" target="_blank"><span class="feature_id">core-27</span>当bodyStuffEmptyCell为false是，不自动填充空行</a><br/>
<a href="core_autoHeight_autoWidth.html" target="_blank"><span class="feature_id">core-28</span>当autoWidth为true时，自动调整grid宽度以保证所有列都同时可见，auto列赋予默认列宽columnWidthDefault</a><br/>
<a href="core_autoHeight_autoWidth.html" target="_blank"><span class="feature_id">core-29</span>当autoHeight为true时，自动调整grid高度以保证当前视图中的所有行同时可见</a><br/>
<a href="core_addRow_removeRow.html" target="_blank"><span class="feature_id">core-30</span>当store中新增一行时，grid自动刷新body以响应更改，但不自动滚动到新行</a><br/>
<a href="core_addRow_removeRow.html" target="_blank"><span class="feature_id">core-31</span>当store中删除一行时，grid自动刷新body以响应更改</a><br/>
<a href="core_addRow_removeRow.html" target="_blank"><span class="feature_id">core-32</span>当store中连续删除多行时，grid只自动刷新一次</a><br/>
<a href="core_addRow_removeRow.html" target="_blank"><span class="feature_id">core-33</span>当store中连续增加多行时，grid只自动刷新一次</a><br/>
<a href="core-34.html" target="_blank"><span class="feature_id">core-34</span>当store中改变某一field的值时，grid自动刷新该field所在的行以响应更改</a><br/>
<a href="core-35.html" target="_blank"><span class="feature_id">core-35</span>[body] body refresh前后 如果存在hScrollerBar或者vScrollerBar，scroll position应该保持一致</a><br/>
<div><span class="feature_id">core-36</span>[body] body.getRowNode若取不到相应的行时，应返回null且不会发生错误</div>
<div><span class="feature_id">core-37</span>[body] body.getCellNode若取不到相应的单元格时，应返回null且不会发生错误</div>
<a href="core-38-39.html" target="_blank"><span class="feature_id">core-38</span>[body] body.refreshCell 在对应的cell存在时应该刷新cell数据，且触发onAfterRow()事件</a><br/>
<a href="core-38-39.html" target="_blank"><span class="feature_id">core-39</span>[body] body.refreshCell 在对应的cell不存在不触发onAfterRow()事件</a><br/>
<a href="core-40.html" target="_blank"><span class="feature_id">core-40</span>当鼠标在body上时，滚动滚轮可纵向滚动body中的内容</a><br/>
<a href="core-41-45.html" target="_blank"><span class="feature_id">core-41</span>[Focus]当header单元格获得焦点时，出现虚线边框</a><br/>
<a href="core-41-45.html" target="_blank"><span class="feature_id">core-42</span>[Focus]当body单元格获得焦点时，出现虚线边框</a><br/>
<a href="core-41-45.html" target="_blank"><span class="feature_id">core-43</span>[Focus]当焦点在header单元格时，左右键移动焦点</a><br/>
<a href="core-41-45.html" target="_blank"><span class="feature_id">core-44</span>[Focus]当焦点在body单元格时，上下左右键移动焦点，PageUp/PageDown向上/向下翻一屏，焦点移到该列在该屏的单元格，若已经在最后一屏，则焦点移到第一行/最后一行该列单元格</a><br/>
<a href="core-41-45.html" target="_blank"><span class="feature_id">core-45</span>[Focus]body的tab序在header之后。</a><br/>
<a href="core-46.html" target="_blank"><span class="feature_id">core-46</span>structure = [] | null | undefined. no error thrown. No column.</a><br/>
<a href="core-46.html" target="_blank"><span class="feature_id">core-47</span>structure = [ {} ]; 1 column; id is 1. Show empty data</a><br/>
<div><span class="feature_id">core-48</span>query: { id: '1*' } </div>
<div><span class="feature_id">core-49</span>queryOptions: { deep: true }</div>
<a href="core-50.html" target="_blank"><span class="feature_id">core-50</span>autoWidth: false, columnWidthAutoResize: false, 若auto或%列计算出的宽度小于列的minWidth，采用minWidth</a><br/>
<div><span class="feature_id">core-51</span>grid.body.refresh(start)</div>
<div><span class="feature_id">core-52</span>grid.body.refresh() </div>
<a href="core-53.html" target="_blank"><span class="feature_id">core-53</span>grid.resize({ h: ..., w: ... });</a><br/>
<a href="core_resize.html" target="_blank"><span class="feature_id">core-54</span>grid.resize({ h: ... });</a><br/>
<a href="core_resize.html" target="_blank"><span class="feature_id">core-55</span>grid.resize({ w: ... });</a><br/>
<a href="core_resize.html" target="_blank"><span class="feature_id">core-56</span>grid.resize(); fit parent size</a><br/>
<div><span class="feature_id">core-57</span>autoHeight grid, grid.resize(), height still auto</div>
<div><span class="feature_id">core-58</span>autoWidth grid, grid.resize(), width still auto</div>
<a href="core_columnwidth.html" target="_blank"><span class="feature_id">core-59</span>columnWidthAutoResize, grid.resize()</a><br/>
<a href="core-60.html" target="_blank"><span class="feature_id">core-60</span>grid.setStore(emptyStore)从非空store设置到空store</a><br/>
<a href="core-60.html" target="_blank"><span class="feature_id">core-61</span>grid.setStore(moreDataStore);</a><br/>
<a href="core-60.html" target="_blank"><span class="feature_id">core-62</span>grid.setStore(lessDataStore);</a><br/>
<a href="core-60.html" target="_blank"><span class="feature_id">core-63</span>grid.setStore(grid.store); // do nothing</a><br/>
<div><span class="feature_id">core-64</span>grid.setStore(grid.store, true); // force reload store</div>
<a href="core-46.html" target="_blank"><span class="feature_id">core-65</span>从正常列设置到空列</a><br/>
<a href="core-66.html" target="_blank"><span class="feature_id">core-66</span>从无横向滚动条列布局设置到有横向滚动条列布局</a><br/>
<a href="core-66.html" target="_blank"><span class="feature_id">core-67</span>从有横向滚动条列布局设置到无横向滚动条列布局</a><br/>
<div><span class="feature_id">core-68</span>grid.setColumns(grid.structure)</div>
<a href="core-46.html" target="_blank"><span class="feature_id">core-69</span>从空列设置到正常列</a><br/>
<a href="core-60.html" target="_blank"><span class="feature_id">core-70</span>从空store设置到非空store</a><br/>
<div><span class="feature_id">core-71</span>body.renderWholeRowOnSet为true时，set store之后重新render整行，并且触发对应行的onAfterRow事件</div>
<div><span class="feature_id">core-72</span>body.renderWholeRowOnSet为false时，set store之后只会render有变更的cell，并且会触发相应cell的onAfterCell事件</div>
<a href="core-73.html" target="_blank"><span class="feature_id">core-73</span>非%非auto的固定列宽不受minWidth影响(以width为准)</a><br/>
<div><span class="feature_id">core-74</span>body.compareOnSet可以被用户自定义，当renderWholRowOnSet为false时，set store之后cell数据的比较将使用compareOnSet</div>
<div><span class="feature_id">core-75</span>对于默认compareOnSet，如果cell的新老值都是object,比较toJson的值。反之则直接比较cell的新老值。</div>
<div><span class="feature_id">core-76</span>对于自定义的compareOnset, 如function(){ return false; }, set store之后应该rerender所有的cell</div>
<a href="core-77-80.html" target="_blank"><span class="feature_id">core-77</span>vScroller.scrollToRow() 向下滚动到指定的行，只要该行出现在可视区域内即可</a><br/>
<a href="core-77-80.html" target="_blank"><span class="feature_id">core-78</span>vScroller.scrollToRow() 向上滚动到指定的行，只要该行出现在可视区域内即可</a><br/>
<a href="core-77-80.html" target="_blank"><span class="feature_id">core-79</span>vScroller.scrollToRow() 若指定行号过大，滚动到最后一行</a><br/>
<a href="core-77-80.html" target="_blank"><span class="feature_id">core-80</span>vScroller.scrollToRow() 若第二参数为真值，试图保证目标行出现在可视区域顶部</a><br/>
<a href="core-81.html" target="_blank"><span class="feature_id">core-81</span>vScroller.scrollToRow() 目标行的高度大于grid高度</a><br/>
<a href="core-82.html" target="_blank"><span class="feature_id">core-82</span>body.stuffEmptyCell为true时，对于内容为空的cell，应该用&nbsp;填充</a><br/>
<a href="core-83-84.html" target="_blank"><span class="feature_id">core-83</span>hScroller.scrollToColumn() 滚动到指定列</a><br/>
<a href="core-83-84.html" target="_blank"><span class="feature_id">core-84</span>hScroller.scrollToColumn() 若目标列不存在，no op</a><br/>
<div><span class="feature_id">core-85</span>当所有模块加载完毕时触发onModulesLoaded事件</div>
<a href="core-86.html" target="_blank"><span class="feature_id">core-86</span>对于列声明中没有指定ID的列，自动按序添加ID：1, 2, 3, ....</a><br/>
<a href="core-87-88.html" target="_blank"><span class="feature_id">core-87</span>列声明不指定name，则header上不显示任何列名</a><br/>
<a href="core-87-88.html" target="_blank"><span class="feature_id">core-88</span>列声明不指定field，但指定了formatter函数，则grid数据由formatter函数产生(例如计算两列之和)</a><br/>
<a href="core-89-90.html" target="_blank"><span class="feature_id">core-89</span>列声明style参数为cell添加style</a><br/>
<a href="core-89-90.html" target="_blank"><span class="feature_id">core-90</span>列声明class参数为cell添加class</a><br/>
<a href="core-91.html" target="_blank"><span class="feature_id">core-91</span>列声明style可以是函数</a><br/>
<a href="core-92.html" target="_blank"><span class="feature_id">core-92</span>列声明class可以是函数</a><br/>
<a href="core-93.html" target="_blank"><span class="feature_id">core-93</span>grid创建时，当一行由body完成渲染后触发onAfterRow事件，该事件中行node可用，行cache在客户端</a><br/>
<div><span class="feature_id">core-94</span>显示出来的行的cache一定在客户端</div>
<a href="core-95-101.html" target="_blank"><span class="feature_id">core-95</span>当鼠标悬浮在body上滚动滚轮时，vScrller纵向滚动</a><br/>
<a href="core-95-101.html" target="_blank"><span class="feature_id">core-96</span>当鼠标拖动vScroller bar时，滚动grid</a><br/>
<a href="core-95-101.html" target="_blank"><span class="feature_id">core-97</span>当鼠标点击vScroller bar空白区域时，滚动grid</a><br/>
<a href="core-95-101.html" target="_blank"><span class="feature_id">core-98</span>当鼠标点击vScroller bar两端按钮时，滚动grid</a><br/>
<a href="core-95-101.html" target="_blank"><span class="feature_id">core-99</span>当鼠标拖动hScroller bar时，横向滚动</a><br/>
<a href="core-95-101.html" target="_blank"><span class="feature_id">core-100</span>当鼠标点击hScroller bar空白区域时，横向滚动</a><br/>
<a href="core-95-101.html" target="_blank"><span class="feature_id">core-101</span>当鼠标点击hScroller bar两端按钮时，横向滚动grid</a><br/>
<a href="core-102.html" target="_blank"><span class="feature_id">core-102</span>[RTL]vScroller bar出现在左侧</a><br/>
<a href="core-103.html" target="_blank"><span class="feature_id">core-103</span>若modules中有未加载的模块，console输出警告，但不影响grid创建</a><br/>
<a href="core-104.html" target="_blank"><span class="feature_id">core-104</span>若modules中有未加载的被强制依赖的模块，console输出警告，grid放弃创建</a><br/>
<a href="core-105.html" target="_blank"><span class="feature_id">core-105</span>若modules中有多个name相同的模块，则只加载最后一个</a><br/>
<a href="core-106.html" target="_blank"><span class="feature_id">core-106</span>grid能够在display:none的情况下创建，在display:block时resize()，'auto' 宽度和%宽度列计算正确</a><br/>
<a href="core-107.html" target="_blank"><span class="feature_id">core-107</span>当autoHeight时，鼠标在body上滚动滚轮将滚动整个页面</a><br/>
<div><span class="feature_id">core-108</span></div>
<div><span class="feature_id">core-109</span></div>
<div><span class="feature_id">core-110</span></div>
<div><span class="feature_id"></span>undefined</div>