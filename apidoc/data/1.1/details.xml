<javascript version="1"><object location="gridx/Grid" type="constructor" classlike="true" superclass="gridx/core/Core"><properties><property name="templateString" scope="prototype" type="undefined" from="gridx/Grid"/><property name="coreModules" scope="prototype" type="Array" from="gridx/Grid"/><property name="coreExtensions" scope="prototype" type="Array" from="gridx/Grid"/><property name="autoHeight" scope="prototype" type="Boolean" from="gridx/Grid"><summary>&lt;p>If true, the grid&amp;#39;s height is determined by the total height of the rows in current body view,
so that there will never be vertical scroller bar. And when scrolling the mouse wheel over grid body,
the whole page will be scrolled. Note if this is false, only the grid body will be scrolled.&lt;/p>
</summary></property><property name="autoWidth" scope="prototype" type="Boolean" from="gridx/Grid"><summary>&lt;p>If true, the grid&amp;#39;s width is determined by the total width of the columns, so that there will
never be horizontal scroller bar.&lt;/p>
</summary></property><property name="_compNames" scope="prototype" type="Array" from="gridx/Grid"/><property name="_eventNames" scope="prototype" type="Array" from="gridx/Grid"/></properties><methods><method name="postCreate" scope="prototype" type="function" from="gridx/Grid" tags="protected extension"><parameters/><return-types/><summary>&lt;p>Override to initialize grid modules&lt;/p>
</summary></method><method name="startup" scope="prototype" type="function" from="gridx/Grid" tags="public extension"><parameters/><return-types/><summary>&lt;p>Startup this grid widget&lt;/p>
</summary></method><method name="destroy" scope="prototype" type="function" from="gridx/Grid" tags="public extension"><parameters/><return-types/><summary>&lt;p>Destroy this grid widget&lt;/p>
</summary></method><method name="resize" scope="prototype" type="function" from="gridx/Grid" tags="public"><parameters><parameter name="changeSize" type="Object" usage="optional"><summary>&lt;p>An object like {w: ..., h: ...}.
If omitted, the grid will re-layout itself in current width/height.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Resize the grid using given width and height.&lt;/p>
</summary></method><method name="_onResizeBegin" scope="prototype" type="function" from="gridx/Grid"><parameters/><return-types/></method><method name="_onResizeEnd" scope="prototype" type="function" from="gridx/Grid"><parameters/><return-types/></method><method name="_initEvents" scope="prototype" type="function" from="gridx/Grid"><parameters><parameter name="objNames" type="undefined" usage="required"/><parameter name="evtNames" type="undefined" usage="required"/></parameters><return-types/></method><method name="_connectEvents" scope="prototype" type="function" from="gridx/Grid"><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="connector" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types/></method><method name="_isConnected" scope="prototype" type="function" from="gridx/Grid"><parameters><parameter name="eventName" type="undefined" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types></method><method name="_isCopyEvent" scope="prototype" type="function" from="gridx/Grid"><parameters><parameter name="evt" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>On Mac Ctrl+click also opens a context menu. So call this to check ctrlKey instead of directly call evt.ctrlKey
if you need to implement some handler for Ctrl+click.&lt;/p>
</summary></method><method name="setStore" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="store" type="undefined" usage="required"><summary>&lt;p>The new data store&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Change the store for grid.&lt;/p>
</summary></method><method name="setColumns" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="columns" type="Array" usage="required"><summary>&lt;p>The new column structure&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Change all the column definitions for grid.&lt;/p>
</summary></method><method name="row" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="row" type="Integer|String" usage="required"><summary>&lt;p>Row index of row ID&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="optional"><summary>&lt;p>If the row parameter is a numeric ID, set this to true&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid and row data is in cache, return a row object, else return null.&lt;/p>
</return-description><summary>&lt;p>Get a row object by ID or index.
For asyc store, if the data of this row is not in cache, then null will be returned.&lt;/p>
</summary></method><method name="column" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="column" type="Integer|String" usage="required"><summary>&lt;p>Column index or column ID&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="required"><summary>&lt;p>If the column parameter is a numeric ID, set this to true&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid return a column object, else return NULL&lt;/p>
</return-description><summary>&lt;p>Get a column object by ID or index&lt;/p>
</summary></method><method name="cell" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="row" type="gridx.core.Row|Integer|String" usage="required"><summary>&lt;p>Row index or row ID or a row object&lt;/p>
</summary></parameter><parameter name="column" type="gridx.core.Column|Integer|String" usage="required"><summary>&lt;p>Column index or column ID or a column object&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="optional"><summary>&lt;p>If the row and coumn params are numeric IDs, set this to true&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid and the row is in cache return a cell object, else return null.&lt;/p>
</return-description><summary>&lt;p>Get a cell object&lt;/p>
</summary></method><method name="columnCount" scope="prototype" type="function" from="gridx/core/Core"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The count of columns&lt;/p>
</return-description><summary>&lt;p>Get the number of columns&lt;/p>
</summary></method><method name="rowCount" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="parentId" type="String" usage="optional"><summary>&lt;p>If provided, return the child count of the given parent row.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The count of rows. -1 if the size info is not available (using server side store and never fetched any data)&lt;/p>
</return-description><summary>&lt;p>Get the number of rows.&lt;/p>
</summary><description>&lt;p>For async store, the return value is valid only when the grid has fetched something from the store.&lt;/p>
</description></method><method name="columns" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="start" type="Integer" usage="optional"><summary>&lt;p>The index of the first column in the returned array.
If omitted, defaults to 0, so grid.columns() gets all the columns.&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="optional"><summary>&lt;p>The number of columns to return.
If omitted, all the columns starting from &amp;#39;start&amp;#39; will be returned.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>An array of column objects&lt;/p>
</return-description><summary>&lt;p>Get a range of columns, from index &amp;#39;start&amp;#39; to index &amp;#39;start + count&amp;#39;.&lt;/p>
</summary></method><method name="rows" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="start" type="Integer" usage="optional"><summary>&lt;p>The index of the first row in the returned array.
If omitted, defaults to 0, so grid.rows() gets all the rows.&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="optional"><summary>&lt;p>The number of rows to return.
If omitted, all the rows starting from &amp;#39;start&amp;#39; will be returned.&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>An array of row objects&lt;/p>
</return-description><summary>&lt;p>Get a range of rows, from index &amp;#39;start&amp;#39; to index &amp;#39;start + count&amp;#39;.&lt;/p>
</summary><description>&lt;p>For async store, if some rows are not in cache, then there will be NULLs in the returned array.&lt;/p>
</description></method><method name="onModulesLoaded" scope="prototype" type="function" from="gridx/core/Core" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when all grid modules are loaded. Can be used as a signal of grid creation complete.&lt;/p>
</summary></method></methods><mixins><mixin location="gridx/core/Core"/></mixins><summary>&lt;p>Gridx is a highly extensible widget providing grid/table functionalities. &lt;/p>
</summary><description>&lt;p>Gridx is much smaller, faster, more reasonable designed, more powerful and more flexible 
compared to the old dojo DataGrid/EnhancedGrid.&lt;/p>
</description></object><object location="gridx/core/Core" type="constructor" classlike="true"><properties/><methods><method name="setStore" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="store" type="undefined" usage="required"><summary>&lt;p>The new data store&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Change the store for grid.&lt;/p>
</summary></method><method name="setColumns" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="columns" type="Array" usage="required"><summary>&lt;p>The new column structure&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Change all the column definitions for grid.&lt;/p>
</summary></method><method name="row" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="row" type="Integer|String" usage="required"><summary>&lt;p>Row index of row ID&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="optional"><summary>&lt;p>If the row parameter is a numeric ID, set this to true&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid and row data is in cache, return a row object, else return null.&lt;/p>
</return-description><summary>&lt;p>Get a row object by ID or index.
For asyc store, if the data of this row is not in cache, then null will be returned.&lt;/p>
</summary></method><method name="column" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="column" type="Integer|String" usage="required"><summary>&lt;p>Column index or column ID&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="required"><summary>&lt;p>If the column parameter is a numeric ID, set this to true&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid return a column object, else return NULL&lt;/p>
</return-description><summary>&lt;p>Get a column object by ID or index&lt;/p>
</summary></method><method name="cell" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="row" type="gridx.core.Row|Integer|String" usage="required"><summary>&lt;p>Row index or row ID or a row object&lt;/p>
</summary></parameter><parameter name="column" type="gridx.core.Column|Integer|String" usage="required"><summary>&lt;p>Column index or column ID or a column object&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="optional"><summary>&lt;p>If the row and coumn params are numeric IDs, set this to true&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid and the row is in cache return a cell object, else return null.&lt;/p>
</return-description><summary>&lt;p>Get a cell object&lt;/p>
</summary></method><method name="columnCount" scope="prototype" type="function" from="gridx/core/Core"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The count of columns&lt;/p>
</return-description><summary>&lt;p>Get the number of columns&lt;/p>
</summary></method><method name="rowCount" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="parentId" type="String" usage="optional"><summary>&lt;p>If provided, return the child count of the given parent row.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The count of rows. -1 if the size info is not available (using server side store and never fetched any data)&lt;/p>
</return-description><summary>&lt;p>Get the number of rows.&lt;/p>
</summary><description>&lt;p>For async store, the return value is valid only when the grid has fetched something from the store.&lt;/p>
</description></method><method name="columns" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="start" type="Integer" usage="optional"><summary>&lt;p>The index of the first column in the returned array.
If omitted, defaults to 0, so grid.columns() gets all the columns.&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="optional"><summary>&lt;p>The number of columns to return.
If omitted, all the columns starting from &amp;#39;start&amp;#39; will be returned.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>An array of column objects&lt;/p>
</return-description><summary>&lt;p>Get a range of columns, from index &amp;#39;start&amp;#39; to index &amp;#39;start + count&amp;#39;.&lt;/p>
</summary></method><method name="rows" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="start" type="Integer" usage="optional"><summary>&lt;p>The index of the first row in the returned array.
If omitted, defaults to 0, so grid.rows() gets all the rows.&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="optional"><summary>&lt;p>The number of rows to return.
If omitted, all the rows starting from &amp;#39;start&amp;#39; will be returned.&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>An array of row objects&lt;/p>
</return-description><summary>&lt;p>Get a range of rows, from index &amp;#39;start&amp;#39; to index &amp;#39;start + count&amp;#39;.&lt;/p>
</summary><description>&lt;p>For async store, if some rows are not in cache, then there will be NULLs in the returned array.&lt;/p>
</description></method><method name="onModulesLoaded" scope="prototype" type="function" from="gridx/core/Core" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when all grid modules are loaded. Can be used as a signal of grid creation complete.&lt;/p>
</summary></method></methods><summary>&lt;p>This is the logical grid (also the base class of the grid widget), 
providing grid data model and defines a module/plugin framework
so that the whole grid can be as flexible as possible while still convenient enough for
web page developers.&lt;/p>
</summary></object><object location="gridx/core/model/Model" type="constructor" classlike="true"><properties/><methods><method name="clearCache" scope="prototype" type="function" from="gridx/core/model/Model"><parameters/><return-types/></method><method name="isId" scope="prototype" type="function" from="gridx/core/model/Model"><parameters/><return-types/></method><method name="byIndex" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="index" type="Integer" usage="required"><summary>&lt;p>The row index&lt;/p>
</summary></parameter><parameter name="parentId" type="String" usage="optional"><summary>&lt;p>If parentId is valid, the row index means the child index under this parent.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="null"/></return-types><return-description>&lt;p>The row cache&lt;/p>
</return-description><summary>&lt;p>Get the row cache by row index.&lt;/p>
</summary></method><method name="byId" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="null"/></return-types><return-description>&lt;p>The row cache&lt;/p>
</return-description><summary>&lt;p>Get the row cache by row id&lt;/p>
</summary></method><method name="indexToId" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="index" type="Integer" usage="required"><summary>&lt;p>The index of the deleted row.&lt;/p>
</summary></parameter><parameter name="parentId" type="String" usage="optional"><summary>&lt;p>If parentId is valid, the row index means the child index under this parent.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="string"/></return-types><return-description>&lt;p>The row ID&lt;/p>
</return-description><summary>&lt;p>Transform row index to row ID&lt;/p>
</summary></method><method name="idToIndex" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="number"/></return-types><return-description>&lt;p>The row index&lt;/p>
</return-description><summary>&lt;p>Transform row ID to row index&lt;/p>
</summary></method><method name="treePath" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="Array"/></return-types><return-description>&lt;p>An array of parent row IDs, from root to parent.
Root level rows have parent of id &amp;quot;&amp;quot;(empty string).&lt;/p>
</return-description><summary>&lt;p>Get tree path of row by row ID&lt;/p>
</summary></method><method name="parent" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="Array"/></return-types><return-description>&lt;p>The parent ID.&lt;/p>
</return-description><summary>&lt;p>Get the parent ID of the given row.&lt;/p>
</summary></method><method name="hasChildren" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="boolean"/></return-types><return-description>&lt;p>Whether this row has child rows.&lt;/p>
</return-description><summary>&lt;p>Check whether a row has children rows.&lt;/p>
</summary></method><method name="children" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="Array"/></return-types><return-description>&lt;p>An array of row IDs&lt;/p>
</return-description><summary>&lt;p>Get IDs of children rows.&lt;/p>
</summary></method><method name="size" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="parentId" type="String" usage="optional"><summary>&lt;p>The ID of a parent row. No parentId means root rows.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="number"/></return-types><return-description>&lt;p>The count of (child) rows&lt;/p>
</return-description><summary>&lt;p>Get the count of rows under the given parent. &lt;/p>
</summary></method><method name="keep" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Lock up a row cache in memory, avoid clearing it out when cache size is reached.&lt;/p>
</summary></method><method name="free" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="id" type="String" usage="optional"><summary>&lt;p>The row ID. If omitted, all kept rows will be freed.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Unlock a row cache in memory, so that it could be cleared out when cache size is reached.&lt;/p>
</summary></method><method name="when" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="args" type="Object|null" usage="optional"><summary>&lt;p>Indicate what rows are needed by listing row IDs or row indexes.
Acceptable args include: 
1. A single row index.
e.g.: model.when(1, ...)
2. A single row index range object in form of: {start: ..., count: ...}.
If count is omitted, means all remaining rows.
e.g.: model.when({start: 10, count: 100}, ...)
3. An array of row indexes and row index ranges.
e.g.: model.when([0, 1, {start: 10, count: 3}, 100], ...)
4. An object with property &amp;quot;index&amp;quot; set to the array defined in 3.
e.g.: model.when({
    index: [0, 1, {start: 10, count: 3}, 100]
}, ...)
5. An object with property &amp;quot;id&amp;quot; set to an array of row IDs.
e.g.: model.when({
id: [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]
}, ...)
6. An object containing both contents defined in 4 and 5.
7. An empty object
The model will fetch the store size. Currently it is implemented by fetching the first page of data.
8. null or call this method without any arguments.
This is useful when we only need to execute pending data operations but don&amp;#39;t need to fetch rows.&lt;/p>
</summary></parameter><parameter name="callback" type="Function" usage="optional"><summary>&lt;p>The callback function is called when all the pending data operations are executed and all&lt;/p>
</summary></parameter><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A Deferred object indicating when all this process is finished. Note that in this Deferred object,
The needed rows might not be available since they might be cleared up to reduce memory usage.&lt;/p>
</return-description><summary>&lt;p>Call this method to make sure all the pending data operations are executed and
all the needed rows are at client side.&lt;/p>
</summary><description>&lt;p>This method makes it convenient to do various grid operations without worrying too much about server side
or client side store. This method is the only asynchronous public method in grid model, so that most of
the custom code can be written in synchronous way.&lt;/p>
</description></method><method name="scan" scope="prototype" type="function" from="gridx/core/model/Model"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>An object containing scan arguments&lt;/p>
</summary></parameter><parameter name="callback" type="undefined" usage="required"><summary>&lt;p>The callback function.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If return true in this function, the scan process will end immediately.&lt;/p>
</return-description><summary>&lt;p>Go through all the rows in several batches from start to end (or according to given args),
and execute the callback function for every batch of rows.&lt;/p>
</summary></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/Model" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when a row is deleted from store&lt;/p>
</summary></method><method name="onNew" scope="prototype" type="function" from="gridx/core/model/Model" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when a row is added to the store&lt;/p>
</summary></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/Model" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when a row&amp;#39;s data is changed&lt;/p>
</summary></method><method name="onSizeChange" scope="prototype" type="function" from="gridx/core/model/Model" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when the size of the grid model is changed&lt;/p>
</summary></method><method name="query" scope="normal" type="function" from="gridx/core/model/extensions/Query" extension-module="true"><parameters/><return-types/></method><method name="sort" scope="normal" type="function" from="gridx/core/model/extensions/Sort" extension-module="true"><parameters/><return-types/></method><method name="getMark" scope="normal" type="function" from="gridx/core/model/extensions/Mark" extension-module="true"><parameters/><return-types/></method><method name="getMarkedIds" scope="normal" type="function" from="gridx/core/model/extensions/Mark" extension-module="true"><parameters/><return-types/></method><method name="markById" scope="normal" type="function" from="gridx/core/model/extensions/Mark" extension-module="true"><parameters/><return-types/></method><method name="markByIndex" scope="normal" type="function" from="gridx/core/model/extensions/Mark" extension-module="true"><parameters/><return-types/></method><method name="clearMark" scope="normal" type="function" from="gridx/core/model/extensions/Mark" extension-module="true"><parameters/><return-types/></method><method name="treeMarkMode" scope="normal" type="function" from="gridx/core/model/extensions/Mark" extension-module="true"><parameters/><return-types/></method><method name="onMarkChange" scope="normal" type="function" from="gridx/core/model/extensions/Mark" extension-module="true"><parameters/><return-types/></method><method name="filter" scope="normal" type="function" from="gridx/core/model/extensions/ClientFilter" extension-module="true"><parameters/><return-types/></method><method name="hasFilter" scope="normal" type="function" from="gridx/core/model/extensions/ClientFilter" extension-module="true"><parameters/><return-types/></method><method name="onFilterProgress" scope="normal" type="function" from="gridx/core/model/extensions/ClientFilter" extension-module="true"><parameters/><return-types/></method><method name="move" scope="normal" type="function" from="gridx/core/model/extensions/Move" extension-module="true"><parameters/><return-types/></method><method name="moveIndexes" scope="normal" type="function" from="gridx/core/model/extensions/Move" extension-module="true"><parameters/><return-types/></method><method name="insert" scope="normal" type="function" from="gridx/core/model/extensions/Move" extension-module="true"><parameters/><return-types/></method><method name="onMoved" scope="normal" type="function" from="gridx/core/model/extensions/Move" extension-module="true"><parameters/><return-types/></method></methods><summary>&lt;p>This class handles all of the data logic in grid.&lt;/p>
</summary><description>&lt;p>It provides a clean and useful set of APIs to encapsulate complicated data operations, 
even for huge asynchronous (server side) data stores.
It is built upon a simple extension mechanism, allowing new (even user defined) data operaions to be pluged in.
An instance of this class can be regarded as a stand-alone logic grid providing consistent data processing 
functionalities. This class can even be instanticated alone without any grid UI.&lt;/p>
</description></object><object location="gridx/core/Row" type="constructor" classlike="true"><properties><property name="id" scope="prototype" type="String" from="gridx/core/Row" tags="readonly"><summary>&lt;p>The ID of this row&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/Row" tags="readonly"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="grid.core.model.Model" from="gridx/core/Row" tags="readonly"><summary>&lt;p>Reference to this grid model&lt;/p>
</summary></property></properties><methods><method name="index" scope="prototype" type="function" from="gridx/core/Row"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The row index&lt;/p>
</return-description><summary>&lt;p>Get the index of this row&lt;/p>
</summary></method><method name="parent" scope="prototype" type="function" from="gridx/core/Row"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The parent row object&lt;/p>
</return-description><summary>&lt;p>Get the parent row of this row.&lt;/p>
</summary></method><method name="cell" scope="prototype" type="function" from="gridx/core/Row"><parameters><parameter name="column" type="gridx.core.Column|Integer|String" usage="required"><summary>&lt;p>Column index or column ID or a column object&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="optional"><summary>&lt;p>If the column parameter is a numeric ID, set this to true&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid return the cell object, else return null.&lt;/p>
</return-description><summary>&lt;p>Get a cell object in this row&lt;/p>
</summary></method><method name="cells" scope="prototype" type="function" from="gridx/core/Row"><parameters><parameter name="start" type="Integer" usage="optional"><summary>&lt;p>The column index of the first cell in the returned array.
If omitted, defaults to 0, so row.cells() gets all the cells.&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="optional"><summary>&lt;p>The number of cells to return.
If omitted, all the cells starting from column &amp;#39;start&amp;#39; will be returned.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>An array of cells in this row&lt;/p>
</return-description><summary>&lt;p>Get cells in this row.&lt;/p>
</summary></method><method name="data" scope="prototype" type="function" from="gridx/core/Row"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>An associative array using column IDs as keys and grid data as values&lt;/p>
</return-description><summary>&lt;p>Get the grid data in this row.&lt;/p>
</summary><description>&lt;p>Grid data means the result of the formatter functions (if exist).
It can be different from store data (a.k.a. raw data).&lt;/p>
</description></method><method name="rawData" scope="prototype" type="function" from="gridx/core/Row"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>An associative array using store fields as keys and store data as values&lt;/p>
</return-description><summary>&lt;p>Get the store data in this row.&lt;/p>
</summary><description>&lt;p>Store data means the data defined in store. It is the data before applying the formatter functions.
It can be different from grid data (a.k.a. formatted data)&lt;/p>
</description></method><method name="item" scope="prototype" type="function" from="gridx/core/Row"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>A store item&lt;/p>
</return-description><summary>&lt;p>Get the store item of this row&lt;/p>
</summary><description>&lt;p>If using the old dojo.data store, store items usually have complicated structures,
and they are also useful when doing store operations.&lt;/p>
</description></method><method name="setRawData" scope="prototype" type="function" from="gridx/core/Row"><parameters><parameter name="rawData" type="Object" usage="required"><summary>&lt;p>The new data to be set. It can be incomplete, only providing a few fields.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If using server side store, a Deferred object is returned to indicate when the operation is finished.&lt;/p>
</return-description><summary>&lt;p>Set new raw data of this row into the store&lt;/p>
</summary></method><method name="node" scope="normal" type="function" from="gridx/modules/Body" extension-module="true"><parameters/><return-types/><summary>&lt;p>Get the dom node of this row.&lt;/p>
</summary></method><method name="visualIndex" scope="normal" type="function" from="gridx/modules/Body" extension-module="true"><parameters/><return-types/><summary>&lt;p>Get the visual index of this row.&lt;/p>
</summary></method></methods><summary>&lt;p>Represents a row of a grid&lt;/p>
</summary><description>&lt;p>An instance of this class represents a grid row.
This class should not be directly instantiated by users. It should be returned by grid APIs.&lt;/p>
</description></object><object location="gridx/core/Column" type="constructor" classlike="true"><properties><property name="id" scope="prototype" type="String" from="gridx/core/Column" tags="readonly"><summary>&lt;p>The ID of this column&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/Column" tags="readonly"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="grid.core.model.Model" from="gridx/core/Column" tags="readonly"><summary>&lt;p>Reference to this grid model&lt;/p>
</summary></property></properties><methods><method name="index" scope="prototype" type="function" from="gridx/core/Column"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The index of this column&lt;/p>
</return-description><summary>&lt;p>Get the index of this column&lt;/p>
</summary></method><method name="def" scope="prototype" type="function" from="gridx/core/Column"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The definition of this column&lt;/p>
</return-description><summary>&lt;p>Get the definition of this column&lt;/p>
</summary></method><method name="cell" scope="prototype" type="function" from="gridx/core/Column"><parameters><parameter name="row" type="gridx.core.Row|Integer|String" usage="required"><summary>&lt;p>Row index or row ID or a row object&lt;/p>
</summary></parameter><parameter name="isId" type="undefined" usage="required"/><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid and the row is in cache return a cell object, else return null&lt;/p>
</return-description><summary>&lt;p>Get a cell object in this column&lt;/p>
</summary></method><method name="cells" scope="prototype" type="function" from="gridx/core/Column"><parameters><parameter name="start" type="Integer" usage="optional"><summary>&lt;p>The row index of the first cell in the returned array.
If omitted, defaults to 0, so column.cells() gets all the cells.&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="optional"><summary>&lt;p>The number of cells to return.
If omitted, all the cells starting from row &amp;#39;start&amp;#39; will be returned.&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>An array of cells in this column&lt;/p>
</return-description><summary>&lt;p>Get cells in this column.
If some rows are not in cache, there will be NULLs in the returned array.&lt;/p>
</summary></method><method name="name" scope="prototype" type="function" from="gridx/core/Column"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The name of this column&lt;/p>
</return-description><summary>&lt;p>Get the name of this column.&lt;/p>
</summary><description>&lt;p>Column name is the string displayed in the grid header cell.
Column names can be anything. Two columns can share one name. But they must have different IDs.&lt;/p>
</description></method><method name="setName" scope="prototype" type="function" from="gridx/core/Column"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>The new name&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>Return self reference, so as to cascade methods&lt;/p>
</return-description><summary>&lt;p>Set the name of this column&lt;/p>
</summary></method><method name="field" scope="prototype" type="function" from="gridx/core/Column"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The store field of this column&lt;/p>
</return-description><summary>&lt;p>Get the store field of this column&lt;/p>
</summary><description>&lt;p>If a column corresponds to a field in store, this method returns the field.
It&amp;#39;s possible for a column to have no store field related.&lt;/p>
</description></method><method name="getWidth" scope="prototype" type="function" from="gridx/core/Column"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The CSS value of column width&lt;/p>
</return-description><summary>&lt;p>Get the width of this column&lt;/p>
</summary></method></methods><summary>&lt;p>Represents a column of a grid&lt;/p>
</summary><description>&lt;p>An instance of this class represents a grid column.
This class should not be directly instantiated by users. It should be returned by grid APIs.&lt;/p>
</description></object><object location="gridx/core/Cell" type="constructor" classlike="true"><properties><property name="row" scope="prototype" type="gridx.core.Row" from="gridx/core/Cell" tags="readonly"><summary>&lt;p>Reference to the row of this cell&lt;/p>
</summary></property><property name="column" scope="prototype" type="null" from="gridx/core/Cell"/><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/Cell" tags="readonly"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="grid.core.model.Model" from="gridx/core/Cell" tags="readonly"><summary>&lt;p>Reference to this grid model&lt;/p>
</summary></property></properties><methods><method name="data" scope="prototype" type="function" from="gridx/core/Cell"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The grid data in this cell&lt;/p>
</return-description><summary>&lt;p>Get the grid data of this cell.&lt;/p>
</summary><description>&lt;p>Grid data means the result of the formatter functions (if exist).
It can be different from store data (a.k.a. raw data).&lt;/p>
</description></method><method name="rawData" scope="prototype" type="function" from="gridx/core/Cell"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The store data of this cell&lt;/p>
</return-description><summary>&lt;p>Get the store data of this cell.&lt;/p>
</summary><description>&lt;p>If the column of this cell has a store field, then this method can return the store data of this cell.&lt;/p>
</description></method><method name="setRawData" scope="prototype" type="function" from="gridx/core/Cell"><parameters><parameter name="rawData" type="undefined" usage="required"><summary>&lt;p>Anything that store can recognize as data&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If using server side store, a Deferred object is returned to indicate when the operation is finished.&lt;/p>
</return-description><summary>&lt;p>Set new raw data to this cell.&lt;/p>
</summary></method><method name="node" scope="normal" type="function" from="gridx/modules/Body" extension-module="true"><parameters/><return-types/><summary>&lt;p>Get the dom node of this cell.&lt;/p>
</summary></method></methods><summary>&lt;p>Represents a cell of a grid&lt;/p>
</summary><description>&lt;p>An instance of this class represents a grid cell.
This class should not be directly instantiated by users. It should be returned by grid APIs.&lt;/p>
</description></object><object location="gridx/core/_Module" type="constructor" classlike="true"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><summary>&lt;p>Base class for gridx modules.&lt;/p>
</summary><description>&lt;p>Actually any dojo class can be a gridx module, but this base class provide some useful methods.&lt;/p>
</description></object><object location="gridx/core/model/extensions/Query" type="constructor" classlike="true" superclass="gridx/core/model/_Extension"><properties/><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/core/model/_Extension"/></mixins><summary>&lt;p>Pass query to store. Using store&amp;#39;s query system.&lt;/p>
</summary></object><object location="gridx/core/model/_Extension" type="constructor" classlike="true"><properties/><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><summary>&lt;p>Abstract base class for all model components (including cache)&lt;/p>
</summary></object><object location="gridx/modules/Header" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="hidden" scope="prototype" type="Boolean" from="gridx/modules/Header"><summary>&lt;p>Whether the header UI should be hidden.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getHeaderNode" scope="prototype" type="function" from="gridx/modules/Header"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The column ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The header DOM node&lt;/p>
</return-description><summary>&lt;p>Get the header DOM node by column ID.&lt;/p>
</summary></method><method name="refresh" scope="prototype" type="function" from="gridx/modules/Header"><parameters/><return-types/><summary>&lt;p>Re-build the header UI.&lt;/p>
</summary></method><method name="onRender" scope="prototype" type="function" from="gridx/modules/Header" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when the header is rendered.&lt;/p>
</summary></method><method name="onMoveToHeaderCell" scope="prototype" type="function" from="gridx/modules/Header" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when the focus is moved to a header cell by keyboard.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>The header UI of grid&lt;/p>
</summary><description>&lt;p>This module is in charge of the rendering of the grid header. But it should not manage column width,
which is the responsibility of ColumnWidth module.&lt;/p>
</description></object><object location="gridx/modules/Body" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="rowHoverEffect" scope="prototype" type="Boolean" from="gridx/modules/Body"><summary>&lt;p>Whether to show a visual effect when mouse hovering a row.&lt;/p>
</summary></property><property name="stuffEmptyCell" scope="prototype" type="Boolean" from="gridx/modules/Body"><summary>&lt;p>Whether to stuff a cell with &amp;nbsp; if it is empty.&lt;/p>
</summary></property><property name="renderWholeRowOnSet" scope="prototype" type="Boolean" from="gridx/modules/Body"><summary>&lt;p>If true, the whole row will be re-rendered even if only one field has changed.
Default to false, so that only one cell will be re-rendered editing that cell.&lt;/p>
</summary></property><property name="rootStart" scope="prototype" type="Integer" from="gridx/modules/Body" tags="readonly"><summary>&lt;p>The row index of the first root row that logically exists in the current body&lt;/p>
</summary></property><property name="rootCount" scope="prototype" type="Integer" from="gridx/modules/Body" tags="readonly"><summary>&lt;p>The count of root rows that logically exist in thi current body&lt;/p>
</summary></property><property name="renderStart" scope="prototype" type="Integer" from="gridx/modules/Body" tags="readonly"><summary>&lt;p>The visual row index of the first renderred row in the current body&lt;/p>
</summary></property><property name="renderCount" scope="prototype" type="Integer" from="gridx/modules/Body" tags="readonly"><summary>&lt;p>The count of renderred rows in the current body.&lt;/p>
</summary></property><property name="visualStart" scope="prototype" type="Integer" from="gridx/modules/Body" tags="readonly"><summary>&lt;p>The visual row index of the first row that is logically visible in the current body.
This should be always zero.&lt;/p>
</summary></property><property name="visualCount" scope="prototype" type="Integer" from="gridx/modules/Body" tags="readonly"><summary>&lt;p>The count of rows that are logically visible in the current body&lt;/p>
</summary></property><property name="autoUpdate" scope="prototype" type="Boolean" from="gridx/modules/Body" private="true" tags="private"><summary>&lt;p>Update grid body automatically when onNew/onSet/onDelete is fired&lt;/p>
</summary></property><property name="autoChangeSize" scope="prototype" type="Boolean" from="gridx/modules/Body" private="true" tags="private"><summary>&lt;p>Whether to change rootStart and rootCount automatically when store size is changed.
This need to be turned off when pagination is used.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="compareOnSet" scope="prototype" type="Function" from="gridx/modules/Body"><parameters><parameter name="v1" type="undefined" usage="required"/><parameter name="v2" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>When data is changed in store, compare the old data and the new data of grid, return true if
they are the same, false if not, so that the body can decide whether to refresh the corresponding cell.&lt;/p>
</summary></method><method name="getRowNode" scope="prototype" type="function" from="gridx/modules/Body"><parameters><parameter name="args" type="gridx.__RowCellInfo" usage="required"><summary>&lt;p>A row info object containing row index or row id&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The DOM node of the row. Null if not found.&lt;/p>
</return-description><summary>&lt;p>Get the DOM node of a row&lt;/p>
</summary></method><method name="getCellNode" scope="prototype" type="function" from="gridx/modules/Body"><parameters><parameter name="args" type="gridx.__RowCellInfo" usage="required"><summary>&lt;p>A cell info object containing sufficient info&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The DOM node of the cell. Null if not found.&lt;/p>
</return-description><summary>&lt;p>Get the DOM node of a cell&lt;/p>
</summary></method><method name="getRowInfo" scope="prototype" type="function" from="gridx/modules/Body"><parameters><parameter name="args" type="gridx.__RowCellInfo" usage="required"><summary>&lt;p>A row info object containing partial row info&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A row info object containing as complete as possible row info.&lt;/p>
</return-description><summary>&lt;p>Get complete row info by partial row info&lt;/p>
</summary></method><method name="refresh" scope="prototype" type="function" from="gridx/modules/Body"><parameters><parameter name="start" type="Integer" usage="optional"><summary>&lt;p>The visual index of the start row that is affected by this rendering. If omitted, all rows are affected.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when the refreshing process is finished.&lt;/p>
</return-description><summary>&lt;p>Refresh the grid body&lt;/p>
</summary></method><method name="refreshCell" scope="prototype" type="function" from="gridx/modules/Body"><parameters><parameter name="rowVisualIndex" type="Integer" usage="required"><summary>&lt;p>The visual index of the row of this cell&lt;/p>
</summary></parameter><parameter name="columnIndex" type="Integer" usage="required"><summary>&lt;p>The index of the column of this cell&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when this refreshing process is finished.&lt;/p>
</return-description><summary>&lt;p>Refresh a single cell&lt;/p>
</summary></method><method name="onAfterRow" scope="prototype" type="function" from="gridx/modules/Body"><parameters/><return-types/><summary>&lt;p>Fired when a row is created, data is filled in, and its node is inserted into the dom tree.&lt;/p>
</summary></method><method name="onAfterCell" scope="prototype" type="function" from="gridx/modules/Body"><parameters/><return-types/><summary>&lt;p>Fired when a cell is updated by cell editor (or store data change), or by cell refreshing.
Note this is not fired when rendering the whole grid. Use onAfterRow in that case.&lt;/p>
</summary></method><method name="onRender" scope="prototype" type="function" from="gridx/modules/Body"><parameters/><return-types/><summary>&lt;p>Fired everytime the grid body content is rendered or updated.&lt;/p>
</summary></method><method name="onUnrender" scope="prototype" type="function" from="gridx/modules/Body"><parameters/><return-types/><summary>&lt;p>Fired when a row is unrendered (removed from the grid dom tree).
Usually, this event is only useful when using virtual scrolling.&lt;/p>
</summary></method><method name="onDelete" scope="prototype" type="function" from="gridx/modules/Body"><parameters/><return-types/><summary>&lt;p>Fired when a row in current view is deleted from the store.
Note if the deleted row is not visible in current view, this event will not fire.&lt;/p>
</summary></method><method name="onSet" scope="prototype" type="function" from="gridx/modules/Body"><parameters/><return-types/><summary>&lt;p>Fired when a row in current view is updated in store.&lt;/p>
</summary></method><method name="onMoveToCell" scope="prototype" type="function" from="gridx/modules/Body"><parameters/><return-types/><summary>&lt;p>Fired when the focus is moved to a body cell by keyboard.&lt;/p>
</summary></method><method name="onEmpty" scope="prototype" type="function" from="gridx/modules/Body"><parameters/><return-types/><summary>&lt;p>Fired when there&amp;#39;s no rows in current body view.&lt;/p>
</summary></method><method name="onForcedScroll" scope="prototype" type="function" from="gridx/modules/Body" private="true" tags="private"><parameters/><return-types/><summary>&lt;p>Fired when the body needs to fetch more data, but there&amp;#39;s no trigger to the scroller.
This is an inner mechanism to solve some problems when using virtual scrolling or pagination.
This event should not be used by grid users.&lt;/p>
</summary></method><method name="collectCellWrapper" scope="prototype" type="function" from="gridx/modules/Body" private="true" tags="private"><parameters/><return-types/><summary>&lt;p>Fired when a cell is being rendered, so as to collect wrappers for the content in this cell.
This is currently an inner mechanism used to implement widgets in cell and tree node.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>The body UI of grid.&lt;/p>
</summary><description>&lt;p>This module is in charge of row rendering. It should be compatible with virtual/non-virtual scroll, 
pagination, details on demand, and even tree structure.&lt;/p>
</description></object><object location="gridx/modules/VLayout" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="register" scope="prototype" type="function" from="gridx/modules/VLayout"><parameters><parameter name="mod" type="Object" usage="required"><summary>&lt;p>The module object&lt;/p>
</summary></parameter><parameter name="nodeName" type="String" usage="required"><summary>&lt;p>The name of the node to be hooked. Must be able to be accessed by mod[nodeName]&lt;/p>
</summary></parameter><parameter name="hookPoint" type="String" usage="required"><summary>&lt;p>The name of a hook point in grid.&lt;/p>
</summary></parameter><parameter name="priority" type="Number" usage="optional"><summary>&lt;p>The priority of the hook node. If less than 0, then it&amp;#39;s above the base node, larger than 0, below the base node.&lt;/p>
</summary></parameter><parameter name="deferReady" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>When the &amp;#39;mod&amp;#39; is loaded or &amp;quot;ready&amp;quot;, hook &amp;#39;mod&amp;#39;[&amp;#39;nodeName&amp;#39;] to grid[&amp;#39;hookPoint&amp;#39;] with priority &amp;#39;priority&amp;#39;&lt;/p>
</summary></method><method name="reLayout" scope="prototype" type="function" from="gridx/modules/VLayout"><parameters/><return-types/><summary>&lt;p>Virtically re-layout all the grid UI parts.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module manages the vertical layout of all the grid UI parts.&lt;/p>
</summary><description>&lt;p>When user creates a grid with a given height, it means the height of the whole grid,
which includes grid body, toobar, pagination bar, headerbar, horizontal scrollerbar, etc.
So the height of the grid body must be calculated out so as to layout the grid properly.
This module calculates grid body height by collecting height from all the registered
grid UI parts. The reLayout function in this module will be called everytime the
grid size is changed.&lt;/p>
</description></object><object location="gridx/modules/HLayout" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="lead" scope="prototype" type="Number" from="gridx/modules/HLayout" private="true" tags="private readonly"><summary>&lt;p>The pixel size of the total width of all the UI parts that are before(LTR: left, RTL: right) the grid body.&lt;/p>
</summary></property><property name="tail" scope="prototype" type="Number" from="gridx/modules/HLayout" private="true" tags="private readonly"><summary>&lt;p>The pixel size of the total width of all the UI parts that are after(LTR: right, RTL: left) the grid body.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="register" scope="prototype" type="function" from="gridx/modules/HLayout" private="true" tags="private"><parameters><parameter name="ready" type="dojo.Deferred|null" usage="required"><summary>&lt;p>A deferred object indicating when the DOM node is ready for width calculation.
If omitted, it means the refNode can be calculated at any time.&lt;/p>
</summary></parameter><parameter name="refNode" type="DOMNode" usage="required"><summary>&lt;p>The DOM node that represents a UI part in grid.&lt;/p>
</summary></parameter><parameter name="isTail" type="Boolean" usage="optional"><summary>&lt;p>If the &amp;#39;refNode&amp;#39; appears after(LTR: right, RTL: left) the grid body, set this to true.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Register a &amp;#39;refNode&amp;#39; so this module can calculate its width when it is &amp;#39;ready&amp;#39;&lt;/p>
</summary></method><method name="reLayout" scope="prototype" type="function" from="gridx/modules/HLayout"><parameters/><return-types/><summary>&lt;p>Re-layout the grid horizontally. This means calculated the width of all registered
grid UI components except the grid body. Then update the grid body width.
Usually there&amp;#39;s no need for users to call this method. It&amp;#39;ll be automatically called
when calling grid.resize().&lt;/p>
</summary></method><method name="onUpdateWidth" scope="prototype" type="function" from="gridx/modules/HLayout" private="true" tags="private"><parameters/><return-types/><summary>&lt;p>Fired when the body width is updated.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module manages the horizontal layout of all grid UI parts.&lt;/p>
</summary><description>&lt;p>When a user creates a grid with a given width, it means the width of the whole grid,
which includes grid body, row header, and virtical scrollerbar (and maybe more in the future).
So the width of the grid body must be calculated out so as to layout the grid properly.
This module calculates grid body width by collecting width from all the registered
grid UI parts. It is assumed that the width of these UI parts will not change when grid is resized.&lt;/p>
</description></object><object location="gridx/modules/VScroller" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="scrollToRow" scope="prototype" type="function" from="gridx/modules/VScroller"><parameters><parameter name="rowVisualIndex" type="Integer" usage="required"><summary>&lt;p>The visual index of the row&lt;/p>
</summary></parameter><parameter name="toTop" type="Boolean" usage="optional"><summary>&lt;p>If set this to true, the grid will try to scroll the required row to the top of the view.
Otherwise, the grid will stop scrolling as soon as the row is visible.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when the scrolling process is finished. This will be useful
when using lazy-loading and lazy-rendering.&lt;/p>
</return-description><summary>&lt;p>Scroll the grid until the required row is in view.&lt;/p>
</summary><description>&lt;p>This job will be an asynchronous one if the lazy-loading and lazy-rendering are used.&lt;/p>
</description></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides basic vertical scrolling logic for grid.&lt;/p>
</summary><description>&lt;p>This module will make the grid body render all rows without paging.
So it is very fast for small client side store, and might be extremely slow
for large server side store.&lt;/p>
</description></object><object location="gridx/modules/HScroller" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="scrollToColumn" scope="prototype" type="function" from="gridx/modules/HScroller"><parameters><parameter name="colId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Scroll the grid to make a column fully visible.&lt;/p>
</summary></method><method name="refresh" scope="prototype" type="function" from="gridx/modules/HScroller"><parameters/><return-types/><summary>&lt;p>Refresh scroller itself to match grid body&lt;/p>
</summary></method><method name="scroll" scope="prototype" type="function" from="gridx/modules/HScroller" private="true" tags="private"><parameters><parameter name="left" type="Number" usage="required"><summary>&lt;p>The scrollLeft value&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Scroll the grid horizontally&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides basic horizontal scrolling for grid&lt;/p>
</summary></object><object location="gridx/modules/ColumnWidth" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="default" scope="prototype" type="number" from="gridx/modules/ColumnWidth"/><property name="autoResize" scope="prototype" type="Boolean" from="gridx/modules/ColumnWidth"><summary>&lt;p>If set to true, the column width should be set to auto or percentage values,
so that the column can automatically resize when the grid width is changed.
(This is the default behavior of an HTML table).&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="onUpdate" scope="prototype" type="function" from="gridx/modules/ColumnWidth"><parameters/><return-types/><summary>&lt;p>Fired when column widths are updated.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Manages column width distribution, allow grid autoWidth and column autoResize.&lt;/p>
</summary></object><object location="gridx/modules/Focus" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="registerArea" scope="prototype" type="function" from="gridx/modules/Focus" tags="package"><parameters><parameter name="area" type="__FocusArea" usage="required"><summary>&lt;p>A focus area definition.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Register a new focus area, so this area will be included in the TAB sequence.
If there&amp;#39;s an existing area with the same name, it is removed and replaced by the new area.
This function always succeed. No exception.&lt;/p>
</summary></method><method name="focusArea" scope="prototype" type="function" from="gridx/modules/Focus" tags="package"><parameters><parameter name="areaName" type="undefined" usage="required"/><parameter name="forced" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Focus the area with name of &lt;em>areaName&lt;/em>.
If the current area is not this area, blur the current area.
If the current area is this area, this is a no-op and return TRUE.
If the area with this name does not exist, this is a no-op and return FALSE.&lt;/p>
</summary></method><method name="currentArea" scope="prototype" type="function" from="gridx/modules/Focus" tags="package"><parameters/><return-types/><summary>&lt;p>Get the name of the current focus area. &lt;/p>
</summary></method><method name="tab" scope="prototype" type="function" from="gridx/modules/Focus" tags="package"><parameters><parameter name="step" type="Integer" usage="required"><summary>&lt;p>If positive, then move forward along the TAB sequence.
If negative, then move backward along the TAB sequence (SHIFT-TAB).
If zero or other invalid values, this is a no-op.
The absolute value of &lt;em>step&lt;/em> is the distance between the target area and the current area
in the whole TAB sequence.&lt;/p>
</summary></parameter><parameter name="evt" type="Object" usage="required"><summary>&lt;p>This can either be a real Event object or a mock object with same information .&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Move focus from one area to another.&lt;/p>
</summary></method><method name="removeArea" scope="prototype" type="function" from="gridx/modules/Focus" tags="package"><parameters><parameter name="areaName" type="String" usage="required"><summary>&lt;p>The name of the area to be removed.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove the area with name of &lt;em>areaName&lt;/em>.
If there&amp;#39;s no such area, this is a no-op and return FALSE.
If currently focused area is removed, then current area becomes empty.&lt;/p>
</summary></method><method name="onFocusArea" scope="prototype" type="function" from="gridx/modules/Focus" tags="callback"><parameters><parameter name="areaName" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Fired when an area is focused.&lt;/p>
</summary></method><method name="onBlurArea" scope="prototype" type="function" from="gridx/modules/Focus" tags="callback"><parameters><parameter name="areaName" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Fired when an area is blurred.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins></object><object location="gridx/GridCommon" type="constructor" classlike="true" superclass="gridx/Grid"><properties><property name="coreModules" scope="prototype" type="undefined" from="gridx/GridCommon"/><property name="templateString" scope="prototype" type="undefined" from="gridx/Grid"/><property name="coreExtensions" scope="prototype" type="Array" from="gridx/Grid"/><property name="autoHeight" scope="prototype" type="Boolean" from="gridx/Grid"><summary>&lt;p>If true, the grid&amp;#39;s height is determined by the total height of the rows in current body view,
so that there will never be vertical scroller bar. And when scrolling the mouse wheel over grid body,
the whole page will be scrolled. Note if this is false, only the grid body will be scrolled.&lt;/p>
</summary></property><property name="autoWidth" scope="prototype" type="Boolean" from="gridx/Grid"><summary>&lt;p>If true, the grid&amp;#39;s width is determined by the total width of the columns, so that there will
never be horizontal scroller bar.&lt;/p>
</summary></property><property name="_compNames" scope="prototype" type="Array" from="gridx/Grid"/><property name="_eventNames" scope="prototype" type="Array" from="gridx/Grid"/></properties><methods><method name="cacheClass" scope="prototype" type="constructor" from="gridx/GridCommon"><parameters/><return-types/></method><method name="postCreate" scope="prototype" type="function" from="gridx/Grid" tags="protected extension"><parameters/><return-types/><summary>&lt;p>Override to initialize grid modules&lt;/p>
</summary></method><method name="startup" scope="prototype" type="function" from="gridx/Grid" tags="public extension"><parameters/><return-types/><summary>&lt;p>Startup this grid widget&lt;/p>
</summary></method><method name="destroy" scope="prototype" type="function" from="gridx/Grid" tags="public extension"><parameters/><return-types/><summary>&lt;p>Destroy this grid widget&lt;/p>
</summary></method><method name="resize" scope="prototype" type="function" from="gridx/Grid" tags="public"><parameters><parameter name="changeSize" type="Object" usage="optional"><summary>&lt;p>An object like {w: ..., h: ...}.
If omitted, the grid will re-layout itself in current width/height.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Resize the grid using given width and height.&lt;/p>
</summary></method><method name="_onResizeBegin" scope="prototype" type="function" from="gridx/Grid"><parameters/><return-types/></method><method name="_onResizeEnd" scope="prototype" type="function" from="gridx/Grid"><parameters/><return-types/></method><method name="_initEvents" scope="prototype" type="function" from="gridx/Grid"><parameters><parameter name="objNames" type="undefined" usage="required"/><parameter name="evtNames" type="undefined" usage="required"/></parameters><return-types/></method><method name="_connectEvents" scope="prototype" type="function" from="gridx/Grid"><parameters><parameter name="node" type="undefined" usage="required"/><parameter name="connector" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types/></method><method name="_isConnected" scope="prototype" type="function" from="gridx/Grid"><parameters><parameter name="eventName" type="undefined" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types></method><method name="_isCopyEvent" scope="prototype" type="function" from="gridx/Grid"><parameters><parameter name="evt" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>On Mac Ctrl+click also opens a context menu. So call this to check ctrlKey instead of directly call evt.ctrlKey
if you need to implement some handler for Ctrl+click.&lt;/p>
</summary></method><method name="setStore" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="store" type="undefined" usage="required"><summary>&lt;p>The new data store&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Change the store for grid.&lt;/p>
</summary></method><method name="setColumns" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="columns" type="Array" usage="required"><summary>&lt;p>The new column structure&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Change all the column definitions for grid.&lt;/p>
</summary></method><method name="row" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="row" type="Integer|String" usage="required"><summary>&lt;p>Row index of row ID&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="optional"><summary>&lt;p>If the row parameter is a numeric ID, set this to true&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid and row data is in cache, return a row object, else return null.&lt;/p>
</return-description><summary>&lt;p>Get a row object by ID or index.
For asyc store, if the data of this row is not in cache, then null will be returned.&lt;/p>
</summary></method><method name="column" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="column" type="Integer|String" usage="required"><summary>&lt;p>Column index or column ID&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="required"><summary>&lt;p>If the column parameter is a numeric ID, set this to true&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid return a column object, else return NULL&lt;/p>
</return-description><summary>&lt;p>Get a column object by ID or index&lt;/p>
</summary></method><method name="cell" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="row" type="gridx.core.Row|Integer|String" usage="required"><summary>&lt;p>Row index or row ID or a row object&lt;/p>
</summary></parameter><parameter name="column" type="gridx.core.Column|Integer|String" usage="required"><summary>&lt;p>Column index or column ID or a column object&lt;/p>
</summary></parameter><parameter name="isId" type="Boolean" usage="optional"><summary>&lt;p>If the row and coumn params are numeric IDs, set this to true&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>If the params are valid and the row is in cache return a cell object, else return null.&lt;/p>
</return-description><summary>&lt;p>Get a cell object&lt;/p>
</summary></method><method name="columnCount" scope="prototype" type="function" from="gridx/core/Core"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The count of columns&lt;/p>
</return-description><summary>&lt;p>Get the number of columns&lt;/p>
</summary></method><method name="rowCount" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="parentId" type="String" usage="optional"><summary>&lt;p>If provided, return the child count of the given parent row.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The count of rows. -1 if the size info is not available (using server side store and never fetched any data)&lt;/p>
</return-description><summary>&lt;p>Get the number of rows.&lt;/p>
</summary><description>&lt;p>For async store, the return value is valid only when the grid has fetched something from the store.&lt;/p>
</description></method><method name="columns" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="start" type="Integer" usage="optional"><summary>&lt;p>The index of the first column in the returned array.
If omitted, defaults to 0, so grid.columns() gets all the columns.&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="optional"><summary>&lt;p>The number of columns to return.
If omitted, all the columns starting from &amp;#39;start&amp;#39; will be returned.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>An array of column objects&lt;/p>
</return-description><summary>&lt;p>Get a range of columns, from index &amp;#39;start&amp;#39; to index &amp;#39;start + count&amp;#39;.&lt;/p>
</summary></method><method name="rows" scope="prototype" type="function" from="gridx/core/Core"><parameters><parameter name="start" type="Integer" usage="optional"><summary>&lt;p>The index of the first row in the returned array.
If omitted, defaults to 0, so grid.rows() gets all the rows.&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="optional"><summary>&lt;p>The number of rows to return.
If omitted, all the rows starting from &amp;#39;start&amp;#39; will be returned.&lt;/p>
</summary></parameter><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>An array of row objects&lt;/p>
</return-description><summary>&lt;p>Get a range of rows, from index &amp;#39;start&amp;#39; to index &amp;#39;start + count&amp;#39;.&lt;/p>
</summary><description>&lt;p>For async store, if some rows are not in cache, then there will be NULLs in the returned array.&lt;/p>
</description></method><method name="onModulesLoaded" scope="prototype" type="function" from="gridx/core/Core" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when all grid modules are loaded. Can be used as a signal of grid creation complete.&lt;/p>
</summary></method></methods><mixins><mixin location="gridx/Grid"/></mixins><summary>&lt;p>This is a common configuration for grid with synchronous store
(client side store such as dojo/store/Memory).
Several useful modules are included by default so that users without special
requirements can directly use.
Note: 
1. cacheClass is no need to be provided.
    gridx/core/model/cache/Sync will be used by default.
2. The exact modules used here might change without notification across Gridx versions.
3. The default modules will be loaded here no matter you use them or not. So if code size
    is critical to your project, please use base class gridx/Grid instead.&lt;/p>
</summary><examples><example>&lt;pre>&lt;code>var grid = new GridCommon({
    store: store,
    structure: structure
});&lt;/code>&lt;/pre>
</example></examples></object><object location="gridx/core/model/cache/Sync" type="constructor" classlike="true" superclass="gridx/core/model/cache/_Cache"><properties/><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/core/model/cache/_Cache"/></mixins><summary>&lt;p>Implement a cache for client side store.&lt;/p>
</summary></object><object location="gridx/core/model/cache/_Cache" type="constructor" classlike="true" superclass="gridx/core/model/_Extension"><properties/><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/core/model/_Extension"/></mixins><summary>&lt;p>Abstract base cache class, providing cache data structure and some common cache functions.&lt;/p>
</summary></object><object location="gridx/modules/CellWidget" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="backupCount" scope="prototype" type="Integer" from="gridx/modules/CellWidget"><summary>&lt;p>The count of backup widgets for every column which contains widgets&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="setCellDecorator" scope="prototype" type="function" from="gridx/modules/CellWidget"><parameters><parameter name="rowId" type="String" usage="required"><summary>&lt;p>The row ID of the cell&lt;/p>
</summary></parameter><parameter name="colId" type="String" usage="required"><summary>&lt;p>The column ID of the cell&lt;/p>
</summary></parameter><parameter name="decorator" type="undefined" usage="required"><summary>&lt;p>The decorator function for this cell.&lt;/p>
</summary></parameter><parameter name="setCellValue" type="undefined" usage="required"><summary>&lt;p>This function can be provided to customiz the way of setting widget value&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>This method is used to decorate a specific cell instead of a whole column.&lt;/p>
</summary></method><method name="restoreCellDecorator" scope="prototype" type="function" from="gridx/modules/CellWidget"><parameters><parameter name="rowId" type="String" usage="required"><summary>&lt;p>The row ID of the cell&lt;/p>
</summary></parameter><parameter name="colId" type="String" usage="required"><summary>&lt;p>The column ID of the cell&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Remove a cell decorator defined by the &amp;quot;setCellDecorator&amp;quot; method.&lt;/p>
</summary></method><method name="getCellWidget" scope="prototype" type="function" from="gridx/modules/CellWidget"><parameters><parameter name="rowId" type="string" usage="required"><summary>&lt;p>The row ID of the cell&lt;/p>
</summary></parameter><parameter name="colId" type="string" usage="required"><summary>&lt;p>The column ID of the cell&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Get the CellWidget displayed in the given cell.&lt;/p>
</summary><description>&lt;p>When this module is used, the string returned from decorator function will be
the template string of a CellWidget. This method gets this widget so that
more control can be applied to it.&lt;/p>
</description></method><method name="onCellWidgetCreated" scope="prototype" type="function" from="gridx/modules/CellWidget" tags="callback"><parameters><parameter name="widget" type="gridx.__CellWidget" usage="required"><summary>&lt;p>The created cell widget.&lt;/p>
</summary></parameter><parameter name="cell" type="gridx.core.Cell" usage="required"><summary>&lt;p>The cell object containing this widget.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when a cell widget is created.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module makes it possible to efficiently show widgets within a grid cell.&lt;/p>
</summary><description>&lt;p>Since widget declarations need to be parsed by dojo.parser, it can NOT be directly
created by the decorator function. This module takes advantage of the _TemplatedMixin
and the _WidgetInTemplateMixin so that users can write &amp;quot;templates&amp;quot; containing widgets
in decorator function.
This modules also limits the total number of widgets, so that the performance of grid
can be configured to a tolerable level when there&amp;#39;re lots of widgets in grid.&lt;/p>
</description></object><object location="gridx/modules/Edit" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="begin" scope="prototype" type="function" from="gridx/modules/Edit"><parameters><parameter name="rowId" type="String" usage="required"><summary>&lt;p>The row ID of this cell&lt;/p>
</summary></parameter><parameter name="colId" type="String" usage="required"><summary>&lt;p>The column ID of this cell&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when the cell has completely changed into eidting mode.&lt;/p>
</return-description><summary>&lt;p>Begin to edit a cell with defined editor widget.&lt;/p>
</summary></method><method name="cancel" scope="prototype" type="function" from="gridx/modules/Edit"><parameters><parameter name="rowId" type="String" usage="required"><summary>&lt;p>The row ID of this cell&lt;/p>
</summary></parameter><parameter name="colId" type="String" usage="required"><summary>&lt;p>The column ID of this cell&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when the cell value has been successfully restored.&lt;/p>
</return-description><summary>&lt;p>Cancel the edit. And end the editing state.&lt;/p>
</summary></method><method name="apply" scope="prototype" type="function" from="gridx/modules/Edit"><parameters><parameter name="rowId" type="String" usage="required"><summary>&lt;p>The row ID of this cell&lt;/p>
</summary></parameter><parameter name="colId" type="String" usage="required"><summary>&lt;p>The column ID of this cell&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when the change has been written back to the store.&lt;/p>
</return-description><summary>&lt;p>Apply the edit value to the grid store. And end the editing state.&lt;/p>
</summary></method><method name="isEditing" scope="prototype" type="function" from="gridx/modules/Edit"><parameters><parameter name="rowId" type="String" usage="required"><summary>&lt;p>The row ID of this cell&lt;/p>
</summary></parameter><parameter name="colId" type="String" usage="required"><summary>&lt;p>The column ID of this cell&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>Whether the cell is in eidting mode.&lt;/p>
</return-description><summary>&lt;p>Check whether a cell is in editing mode.&lt;/p>
</summary></method><method name="setEditor" scope="prototype" type="function" from="gridx/modules/Edit"><parameters><parameter name="colId" type="String" usage="required"><summary>&lt;p>A column ID&lt;/p>
</summary></parameter><parameter name="editor" type="Function|String" usage="required"><summary>&lt;p>Class constructor or declared name of an editor widget&lt;/p>
</summary></parameter><parameter name="args" type="Object" usage="optional"><summary>&lt;p>Any args that are related to this editor.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>&lt;p>toEditor: &lt;p>By default the dijit used in an editing cell will use store value.
If this default behavior can not meet the requirement (for example, store data is freely formatted date string,
while the dijit is dijit.form.DateTextBox, which requires a Date object), this function can be used.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>fromEditor: &lt;p>By default when applying an editing cell, the value of the editor dijit will be retreived by get(&amp;#39;value&amp;#39;) and
directly set back to the store. If this can not meet the requirement, this getEditorValue function can be used
to get a suitable value from editor.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>props (String): &lt;p>The properties to be used when creating the dijit in a editing cell.
Just like data-dojo-props for a widget.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>constraints (Object): &lt;p>If the editor widget has some constraints, it can be set here instead of in props.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>useGridData (Boolean): &lt;p>Whether to feed the editor with grid data or store data.
This property is only effective when toEditor is not provided.&lt;/p>&lt;/p>
&lt;/li>
&lt;li>&lt;p>valueField (String): &lt;p>The property name of the editor used to take the data. In most cases it is &amp;quot;value&amp;quot;,
so editor.set(&amp;#39;value&amp;#39;, ...) can do the job.&lt;/p>&lt;/p>
&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types/><summary>&lt;p>Define the editor widget to edit a column of a grid.
The widget should have a get and set method to get value and set value.&lt;/p>
</summary></method><method name="onBegin" scope="prototype" type="function" from="gridx/modules/Edit"><parameters><parameter name="cell" type="gridx.core.Cell" usage="required"><summary>&lt;p>The cell object&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when a cells enters editing mode.&lt;/p>
</summary></method><method name="onApply" scope="prototype" type="function" from="gridx/modules/Edit"><parameters><parameter name="cell" type="gridx.core.Cell" usage="required"><summary>&lt;p>The cell object&lt;/p>
</summary></parameter><parameter name="applySuccess" type="Boolean" usage="required"><summary>&lt;p>Whether the change is successfully applied to the store&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when the change in a cell is applied to the store.&lt;/p>
</summary></method><method name="onCancel" scope="prototype" type="function" from="gridx/modules/Edit"><parameters><parameter name="cell" type="gridx.core.Cell" usage="required"><summary>&lt;p>The cell object&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when an editing cell is canceled.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides editing mode for grid cells.&lt;/p>
</summary><description>&lt;p>This module relies on an implementation of the CellWidget module.
The editing mode means there will be an editable widget appearing in the grid cell.
This implementation also covers &amp;quot;alwaysEditing&amp;quot; mode for grid columns,
which means all the cells in this column are always in editing mode.&lt;/p>
</description></object><object location="gridx/modules/ColumnResizer" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="minWidth" scope="prototype" type="Integer" from="gridx/modules/ColumnResizer"><summary>&lt;p>min column width in px&lt;/p>
</summary></property><property name="detectWidth" scope="prototype" type="number" from="gridx/modules/ColumnResizer"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="setWidth" scope="prototype" type="function" from="gridx/modules/ColumnResizer"><parameters><parameter name="olId" type="undefined" usage="required"/><parameter name="width" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Set width of the target column&lt;/p>
</summary></method><method name="onResize" scope="prototype" type="function" from="gridx/modules/ColumnResizer"><parameters><parameter name="colId" type="undefined" usage="required"/><parameter name="newWidth" type="undefined" usage="required"/><parameter name="oldWidth" type="undefined" usage="required"/></parameters><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Column Resizer machinery.&lt;/p>
</summary><description>&lt;p>This module provides a way to resize column width. &lt;/p>
</description></object><object location="gridx/modules/SingleSort" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="initialOrder" scope="prototype" type="Object|Array" from="gridx/modules/SingleSort"><summary>&lt;p>The initial sort order when grid is created.
This is of the same format of the sort argument of the store fetch function.
If an array of sort orders is provided, only the first will be used.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="sort" scope="prototype" type="function" from="gridx/modules/SingleSort"><parameters><parameter name="colId" type="String" usage="required"><summary>&lt;p>The column ID&lt;/p>
</summary></parameter><parameter name="isDescending" type="Boolean" usage="optional"><summary>&lt;p>Whether to sort the column descendingly&lt;/p>
</summary></parameter><parameter name="skipUpdateBody" type="Boolean" usage="optional"><summary>&lt;p>If set to true, the grid body will not automatically be refreshed after this call,
so that several grid operations could be done altogether
without refreshing the grid over and over.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Sort the grid on given column.&lt;/p>
</summary></method><method name="isSorted" scope="prototype" type="function" from="gridx/modules/SingleSort"><parameters><parameter name="colId" type="String" usage="required"><summary>&lt;p>The columnn ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>Positive number if the column is sorted ascendingly;
Negative number if the column is sorted descendingly;
Zero if the column is not sorted.&lt;/p>
</return-description><summary>&lt;p>Check wheter (and how) the grid is sorted on the given column.&lt;/p>
</summary></method><method name="clear" scope="prototype" type="function" from="gridx/modules/SingleSort"><parameters><parameter name="skipUpdateBody" type="undefined" usage="required"><summary>&lt;p>If set to true, the grid body will not automatically be refreshed after this call,
so that several grid operations could be done altogether
without refreshing the grid over and over.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Clear sort.&lt;/p>
</summary></method><method name="getSortData" scope="prototype" type="function" from="gridx/modules/SingleSort"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>An array containing the sort info&lt;/p>
</return-description><summary>&lt;p>Get an array of objects that can be accepted by the store&amp;#39;s &amp;quot;sort&amp;quot; argument.    &lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides the single column sorting functionality for grid.&lt;/p>
</summary></object><object location="gridx/core/model/extensions/Sort" type="constructor" classlike="true" superclass="gridx/core/model/_Extension"><properties/><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/core/model/_Extension"/></mixins><summary>&lt;p>Using store&amp;#39;s sorting feature. Can define a base sort order for grid.&lt;/p>
</summary></object><object location="gridx/modules/TouchScroll" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Make desktop grid scrollable by touch in mobile devices.&lt;/p>
</summary></object><object location="gridx/modules/extendedSelect/Row" type="constructor" classlike="true" superclass="gridx/modules/extendedSelect/_RowCellBase"><properties><property name="triggerOnCell" scope="prototype" type="Boolean" from="gridx/modules/extendedSelect/Row" tags="readonly"><summary>&lt;p>Whether row will be selected by clicking on cell, false by default      &lt;/p>
</summary></property><property name="treeMode" scope="prototype" type="Boolean" from="gridx/modules/extendedSelect/Row"><summary>&lt;p>Whether to apply tri-state selection for child rows.&lt;/p>
</summary></property><property name="enabled" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingCtrl" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingShift" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="selectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/Row"><parameters><parameter name="rowId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Select a row by id.&lt;/p>
</summary></method><method name="deselectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/Row"><parameters><parameter name="rowId" type="String" usage="required"><summary>&lt;p>The ID of a row.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Deselect a row by id.&lt;/p>
</summary></method><method name="selectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/Row"><parameters><parameter name="rowIndex" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Select a row by index&lt;/p>
</summary></method><method name="deSelectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/Row"><parameters><parameter name="rowIndex" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselect a row by index.&lt;/p>
</summary></method><method name="getSelected" scope="prototype" type="function" from="gridx/modules/extendedSelect/Row"><parameters/><return-types/><summary>&lt;p>Get id array of all selected rows&lt;/p>
</summary></method><method name="isSelected" scope="prototype" type="function" from="gridx/modules/extendedSelect/Row"><parameters/><return-types/><summary>&lt;p>Check if the given rows are all selected.&lt;/p>
</summary></method><method name="clear" scope="prototype" type="function" from="gridx/modules/extendedSelect/Row"><parameters><parameter name="silent" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselected all selected rows;           &lt;/p>
</summary></method><method name="onHighlightChange" scope="prototype" type="function" from="gridx/modules/extendedSelect/Row"><parameters/><return-types/></method><method name="deselectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="start" type="undefined" usage="required"/><parameter name="end" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="onSelectionChange" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="newSelectedIds" type="undefined" usage="required"/><parameter name="oldSelectedIds" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Event: fired when the selection is changed.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/extendedSelect/_RowCellBase"/></mixins><summary>&lt;p>Provides advanced row selections.&lt;/p>
</summary><description>&lt;p>This module provides an advanced way for selecting rows by clicking, swiping, SPACE key, or CTRL/SHIFT CLICK to select multiple rows.
&lt;/p>
</description><examples><example>&lt;ol>
&lt;li>&lt;p>Use select api on grid row object obtained from grid.row(i)&lt;/p>
&lt;p> grid.row(1).select();
 grid.row(1).deselect();
 grid.row(1).isSelected();&lt;/p>
&lt;/li>
&lt;li>&lt;p>Use select api on select.row module&lt;/p>
&lt;p> grid.select.row.selectById(rowId);
 grid.select.row.deSelectById(rowId);
 grid.select.row.isSelected(rowId);
 grid.select.row.getSelected();//[]
 grid.select.row.clear();&lt;/p>
&lt;/li>
&lt;/ol>
</example></examples></object><object location="gridx/modules/extendedSelect/_RowCellBase" type="constructor" classlike="true" superclass="gridx/modules/extendedSelect/_Base"><properties><property name="enabled" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingCtrl" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingShift" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="selectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="id" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="deselectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="id" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="selectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="start" type="undefined" usage="required"/><parameter name="end" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="deselectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="start" type="undefined" usage="required"/><parameter name="end" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="onSelectionChange" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="newSelectedIds" type="undefined" usage="required"/><parameter name="oldSelectedIds" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Event: fired when the selection is changed.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/extendedSelect/_Base"/></mixins></object><object location="gridx/modules/extendedSelect/_Base" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="enabled" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingCtrl" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingShift" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="selectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="id" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="deselectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="id" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="selectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="start" type="undefined" usage="required"/><parameter name="end" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="deselectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="start" type="undefined" usage="required"/><parameter name="end" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="onSelectionChange" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="newSelectedIds" type="undefined" usage="required"/><parameter name="oldSelectedIds" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Event: fired when the selection is changed.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins></object><object location="gridx/modules/AutoScroll" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="string" from="gridx/modules/AutoScroll"/><property name="enabled" scope="prototype" type="boolean" from="gridx/modules/AutoScroll"/><property name="vertical" scope="prototype" type="boolean" from="gridx/modules/AutoScroll"/><property name="horizontal" scope="prototype" type="boolean" from="gridx/modules/AutoScroll"/><property name="margin" scope="prototype" type="number" from="gridx/modules/AutoScroll"/><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Automatically scroll the grid body when mouse is on the edge of grid.
Useful for extended selection or drag and drop.
This is a registered module, so othe modules can directly depend on it without explicitly declaring it.&lt;/p>
</summary></object><object location="gridx/core/model/extensions/Mark" type="constructor" classlike="true" superclass="gridx/core/model/_Extension"><properties/><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/core/model/_Extension"/></mixins><summary>&lt;p>Provide a marking system, mainly used by selection.&lt;/p>
</summary></object><object location="gridx/modules/Filter" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="string" from="gridx/modules/Filter"/><property name="serverMode" scope="prototype" type="boolean" from="gridx/modules/Filter"/><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property><property name="before" scope="normal" type="undefined" from="gridx/modules/filter/FilterBar" extension-module="true"/><property name="after" scope="normal" type="undefined" from="gridx/modules/filter/FilterBar" extension-module="true"/></properties><methods><method name="setupFilterQuery" scope="prototype" type="function" from="gridx/modules/Filter"><parameters><parameter name="obj" type="undefined" usage="required"/></parameters><return-types/></method><method name="setFilter" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types/><summary>&lt;p>Apply function &lt;em>checker&lt;/em> as the filter condition to filter every row.&lt;/p>
</summary></method><method name="getFilter" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Return the current checker function.&lt;/p>
</summary></method><method name="refresh" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types/><summary>&lt;p>Re-filter the grid with current filter. Useful when data is changed.&lt;/p>
</summary></method><method name="column" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types/></method><method name="value" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module makes it possible for user to set arbitrary filter condition to grid.&lt;/p>
</summary></object><object location="gridx/core/model/extensions/ClientFilter" type="constructor" classlike="true" superclass="gridx/core/model/_Extension"><properties/><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/core/model/_Extension"/></mixins><summary>&lt;p>Filtering grid data at client side.&lt;/p>
</summary></object><object location="gridx/modules/move/Row" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="moveSelected" scope="prototype" type="Boolean" from="gridx/modules/move/Row"><summary>&lt;p>When moving using keyboard, whether to move all selected rows together.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="move" scope="prototype" type="function" from="gridx/modules/move/Row"><parameters><parameter name="rowIndexes" type="Integer[]" usage="required"><summary>&lt;p>An array of row indexes&lt;/p>
</summary></parameter><parameter name="target" type="Integer" usage="required"><summary>&lt;p>The rows will be moved to the position before the target row&lt;/p>
</summary></parameter><parameter name="skipUpdateBody" type="Boolean" usage="optional"><summary>&lt;p>If set to true, the grid will not refresh immediately, so that several
grid operations can be done altogether.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Move some rows to target position&lt;/p>
</summary></method><method name="moveRange" scope="prototype" type="function" from="gridx/modules/move/Row"><parameters><parameter name="start" type="Integer" usage="required"><summary>&lt;p>The index of the first row to be moved&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="required"><summary>&lt;p>The count of rows to be moved&lt;/p>
</summary></parameter><parameter name="target" type="undefined" usage="required"/><parameter name="skipUpdateBody" type="Boolean" usage="optional"/></parameters><return-types/><summary>&lt;p>Move a range of rows to target position&lt;/p>
</summary></method><method name="onMoved" scope="prototype" type="function" from="gridx/modules/move/Row" tags="callback"><parameters><parameter name="rowIndexMapping" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Fired when row move is performed successfully&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides some APIs to move rows within grid&lt;/p>
</summary><description>&lt;p>This module requires the &amp;quot;Move&amp;quot; model extension.
This module does not include any UI. So different kind of row dnd UI implementations can be built
upon this module.&lt;/p>
</description></object><object location="gridx/core/model/extensions/Move" type="constructor" classlike="true" superclass="gridx/core/model/_Extension"><properties/><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/core/model/_Extension"/></mixins><summary>&lt;p>Move rows by means of sorting a special field (default to &amp;quot;order&amp;quot;).&lt;/p>
</summary></object><object location="gridx/modules/move/Column" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="moveSelected" scope="prototype" type="Boolean" from="gridx/modules/move/Column"><summary>&lt;p>When moving using keyboard, whether to move all selected columns together.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="move" scope="prototype" type="function" from="gridx/modules/move/Column"><parameters><parameter name="columnIndexes" type="Integer[]" usage="required"><summary>&lt;p>The current indexes of columns to move&lt;/p>
</summary></parameter><parameter name="target" type="Integer" usage="required"><summary>&lt;p>The moved columns will be inserted before the column with this index.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Move some columns to the given target position&lt;/p>
</summary></method><method name="moveRange" scope="prototype" type="function" from="gridx/modules/move/Column"><parameters><parameter name="start" type="Integer" usage="required"><summary>&lt;p>The index of the first column to move&lt;/p>
</summary></parameter><parameter name="count" type="Integer" usage="required"><summary>&lt;p>The count of columns to move&lt;/p>
</summary></parameter><parameter name="target" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Move a range of columns to a given target position&lt;/p>
</summary></method><method name="onMoved" scope="prototype" type="function" from="gridx/modules/move/Column" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when column move is performed successfully&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides several APIs to move columns within grid.&lt;/p>
</summary><description>&lt;p>This module does not include any UI. So different kind of column dnd UI implementations can be built
upon this module.
But this module does provide a keyboard support for reordering columns. When focus is on a column header,
pressing CTRL+LEFT/RIGHT ARROW will move the column around within grid.&lt;/p>
</description></object><object location="gridx/modules/ColumnLock" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="count" scope="prototype" type="Integer" from="gridx/modules/ColumnLock" tags="readonly"><summary>&lt;p>Number of columns that will be locked by default&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="lock" scope="prototype" type="function" from="gridx/modules/ColumnLock"><parameters><parameter name="count" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Dynamically lock consecutive #count leading columns.&lt;/p>
</summary></method><method name="unlock" scope="prototype" type="function" from="gridx/modules/ColumnLock"><parameters/><return-types/><summary>&lt;p>Unlock all columns.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Column lock machinery.&lt;/p>
</summary><description>&lt;p>This module provides a way to lock consecutive leading columns. 
Columns can be locked in following ways:
&lt;/p>
</description><examples><example>&lt;ol>
&lt;li>&lt;p>Columns can be locked when Grid is initially rendered&lt;/p>
&lt;p> var grid = new Grid({&lt;/p>
&lt;pre>&lt;code> modules: [
     {moduleClass: gridx.modules.ColumnLock, count: 2}, ...
 ],
 ...&lt;/code>&lt;/pre>
&lt;p> });&lt;/p>
&lt;p> Or another way to set the lock number:&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>var grid = new Grid({
    columnLockCount: 2
    modules: [
        gridx.modules.ColumnLock, ...
    ],
})&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>&lt;p>Lock or unlock columns dynamically&lt;/p>
&lt;p> // lock 2 leading columns
 grid.columnLock.lock(2)&lt;/p>
&lt;p> // unlock all columns
 grid.columnLock.unLock();&lt;/p>
&lt;/li>
&lt;/ol>
</example></examples></object><object location="gridx/core/model/cache/Async" type="constructor" classlike="true" superclass="gridx/core/model/cache/_Cache"><properties><property name="isAsync" scope="prototype" type="Boolean" from="gridx/core/model/cache/Async"><summary>&lt;p>Whether this cache is for asynchronous(server side) store.&lt;/p>
</summary></property><property name="cacheSize" scope="prototype" type="Integer" from="gridx/core/model/cache/Async"><summary>&lt;p>The max cached row count in client side.
By default, do not clear cache when scrolling, this is the same with DataGrid&lt;/p>
</summary></property><property name="pageSize" scope="prototype" type="Integer" from="gridx/core/model/cache/Async"><summary>&lt;p>The recommended row count for every fetch.&lt;/p>
</summary></property></properties><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/core/model/cache/_Cache"/></mixins><summary>&lt;p>Implement lazy-loading for server side store.&lt;/p>
</summary></object><object location="gridx/core/model/extensions/FormatSort" type="constructor" classlike="true" superclass="gridx/core/model/_Extension"><properties/><methods><method name="onNew" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onDelete" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method><method name="onSet" scope="prototype" type="function" from="gridx/core/model/_Extension"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/core/model/_Extension"/></mixins><summary>&lt;p>Make formatted data sortable&lt;/p>
</summary></object><object location="gridx/mobile/Grid" type="constructor" classlike="true"><properties><property name="autoHeight" scope="prototype" type="boolean" from="gridx/mobile/Grid"><summary>&lt;p>If true, it&amp;#39;s must be a children of dojox.mobile.View
and it occupies the rest height of the screen. If false it could be in any container
using a specified height.&lt;/p>
</summary></property><property name="showHeader" scope="prototype" type="boolean" from="gridx/mobile/Grid"><summary>&lt;p>Whether to show the grid header&lt;/p>
</summary></property><property name="vScroller" scope="prototype" type="boolean" from="gridx/mobile/Grid"><summary>&lt;p>Whether to show the virtical scroller&lt;/p>
</summary></property><property name="hScroller" scope="prototype" type="boolean" from="gridx/mobile/Grid"><summary>&lt;p>Whether to show the horizontal scroller&lt;/p>
</summary></property><property name="columns" scope="prototype" type="Object" from="gridx/mobile/Grid"><summary>&lt;p>Column definition to show the grid from store&lt;/p>
</summary><description>&lt;p>An object with the following properties:
&lt;/p>
</description></property></properties><methods><method name="setColumns" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters><parameter name="columns" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Set columns to show for the grid. 
Maybe improve performance by adding/removing some columns instead of re-rendering.&lt;/p>
</summary></method><method name="buildGrid" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters/><return-types/><summary>&lt;p>Build the whole grid&lt;/p>
</summary></method><method name="_buildHeader" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters/><return-types/><summary>&lt;p>Build the grid header when showHeader is true.&lt;/p>
</summary></method><method name="_buildBody" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters><parameter name="items" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Build the grid body&lt;/p>
</summary></method><method name="_createRow" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters><parameter name="item" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Create a grid row by object store item.&lt;/p>
</summary></method><method name="_getCellContent" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters><parameter name="col" type="undefined" usage="required"/><parameter name="item" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Get a cell content by the column definition.
* Currently only support string content, will add support for widget in future.&lt;/p>
</summary></method><method name="buildRendering" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters/><return-types/><summary>&lt;p>Build the grid dom structure.&lt;/p>
</summary></method><method name="resize" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters/><return-types/><summary>&lt;p>Calculate the height of grid body according to the autoHeight property.&lt;/p>
</summary></method><method name="startup" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters/><return-types/></method><method name="onComplete" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters><parameter name="items" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>An handler that is called after the fetch completes.&lt;/p>
</summary></method><method name="onError" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters><parameter name="errorData" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>An error handler.&lt;/p>
</summary></method><method name="onUpdate" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters><parameter name="item" type="undefined" usage="required"/><parameter name="insertedInto" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Adds a new item or updates an existing item.&lt;/p>
</summary></method><method name="onDelete" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters><parameter name="item" type="undefined" usage="required"/><parameter name="removedFrom" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deletes an existing item.&lt;/p>
</summary></method><method name="refresh" scope="prototype" type="function" from="gridx/mobile/Grid"><parameters/><return-types><return-type type="null"/><return-type type="undefined"/></return-types><summary>&lt;p>Fetches the data and generates the list items.&lt;/p>
</summary></method></methods><summary>&lt;p>A mobile grid that has fixed header, footer and a scrollable body.&lt;/p>
</summary></object><object location="gridx/mobile/LazyLoad" type="constructor" classlike="true"><properties><property name="pageSize" scope="prototype" type="number" from="gridx/mobile/LazyLoad"/><property name="lastId" scope="prototype" type="null" from="gridx/mobile/LazyLoad"/></properties><methods><method name="_buildBody" scope="prototype" type="function" from="gridx/mobile/LazyLoad"><parameters><parameter name="items" type="undefined" usage="required"/></parameters><return-types/></method><method name="loadMore" scope="prototype" type="function" from="gridx/mobile/LazyLoad"><parameters/><return-types/><summary>&lt;p>Called when touch load more button.
It loads data from server side and create extra rows at the bottom.
If need to provide custom query information, use aspect.before(grid, &amp;#39;loadMore&amp;#39;)&lt;/p>
</summary></method><method name="_loadMoreComplete" scope="prototype" type="function" from="gridx/mobile/LazyLoad"><parameters><parameter name="results" type="undefined" usage="required"/></parameters><return-types/></method><method name="onError" scope="prototype" type="function" from="gridx/mobile/LazyLoad"><parameters/><return-types/></method><method name="_makeButtonBusy" scope="prototype" type="function" from="gridx/mobile/LazyLoad"><parameters/><return-types/></method><method name="_cancelButtonBusy" scope="prototype" type="function" from="gridx/mobile/LazyLoad"><parameters/><return-types/></method></methods></object><object location="gridx/mobile/PullRefresh" type="constructor" classlike="true"><properties><property name="readyToRefresh" scope="prototype" type="boolean" from="gridx/mobile/PullRefresh"/><property name="state" scope="prototype" type="string" from="gridx/mobile/PullRefresh"/><property name="triggerHeight" scope="prototype" type="number" from="gridx/mobile/PullRefresh"/><property name="lastId" scope="prototype" type="null" from="gridx/mobile/PullRefresh"><summary>&lt;p>used to store last id value for query, so that server side knows the state of grid&lt;/p>
</summary></property></properties><methods><method name="buildRendering" scope="prototype" type="function" from="gridx/mobile/PullRefresh"><parameters/><return-types/><summary>&lt;p>Add pull refresh related ui elements, and connect events to them.&lt;/p>
</summary></method><method name="loadNew" scope="prototype" type="function" from="gridx/mobile/PullRefresh"><parameters/><return-types/><summary>&lt;p>Called when pull refresh triggers.
It loads data from server side and create extra rows at the top.&lt;/p>
</summary></method><method name="_loadNewComplete" scope="prototype" type="function" from="gridx/mobile/PullRefresh"><parameters><parameter name="results" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Called after store finishes fetching data from server side.&lt;/p>
</summary></method><method name="_setPullRefreshState" scope="prototype" type="function" from="gridx/mobile/PullRefresh"><parameters><parameter name="state" type="undefined" usage="required"><summary>&lt;p>normal|ready|loading&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Set state of the grid&lt;/p>
</summary></method><method name="_buildBody" scope="prototype" type="function" from="gridx/mobile/PullRefresh"><parameters/><return-types/></method></methods></object><object location="gridx/mobile/Sort" type="constructor" classlike="true"><properties/><methods><method name="sort" scope="prototype" type="function" from="gridx/mobile/Sort"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Sort the grid by args which in store sorting format.&lt;/p>
</summary></method><method name="_buildHeader" scope="prototype" type="function" from="gridx/mobile/Sort"><parameters/><return-types/><summary>&lt;p>Add click to sort capability for header, only for single sort.&lt;/p>
</summary></method><method name="updateSortIndicators" scope="prototype" type="function" from="gridx/mobile/Sort"><parameters/><return-types/><summary>&lt;p>Update the sorting indicators. Maybe override to provide other sorting UI.
Only support single sort now&lt;/p>
</summary></method></methods><summary>&lt;p>Provide sort api for the grid
and provide a single UI in the header like traditional grid sorting.&lt;/p>
</summary></object><object location="gridx/modules/Bar" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="string" from="gridx/modules/Bar"/><property name="top" scope="prototype" type="Array" from="gridx/modules/Bar"><summary>&lt;p>An array of bar content declarations. Located above grid header.
The top bar is big html table, and every content occupies a cell in it.
If it is a single demension array, then the top bar will contain only one row.
If it is a 2 demension array, then every sub-array represents a row.
For example:
[
    gridx.support.QuickFilter,      //can be the constructor of a bar plugin widget.
    &amp;quot;gridx/support/Summary&amp;quot;         //can also be the MID of a bar plugin widget.
    {pluginClass: gridx.support.LinkSizer, style: &amp;quot;text-align: center;&amp;quot;}        //or an object with attributes
]
or
[
    [       //every sub-array is a table row.
        {content: &amp;quot;This is &lt;b>a message&lt;/b>&amp;quot;, style: &amp;quot;backgroun-color: blue;&amp;quot;}, //Can add some html
        null    //if null, just an empty cell
    ],
    [
        {pluginClass: gridx.support.LinkPager, &amp;#39;class&amp;#39;: &amp;#39;myclass&amp;#39;},     //can provide custom class
        {colSpan: 2, rowSpan: 2}    //can add colSpan and rowSpan
    ]
]&lt;/p>
</summary></property><property name="bottom" scope="prototype" type="Array" from="gridx/modules/Bar"><summary>&lt;p>An array of bar content declarations. Located below grid horizontal scroller.
Usage is similar to the &amp;quot;top&amp;quot; attribute.&lt;/p>
</summary></property><property name="plugins" scope="prototype" type="Object" from="gridx/modules/Bar" tags="readonly"><summary>&lt;p>A place to access to the plugins.
For plugins in top bar, use plugins.top, which is an array of bar rows.
e.g.: plugins.top[0][0] is the first plugin the first row of the top bar.
plugin.bottom is similar.&lt;/p>
</summary></property><property name="module" scope="prototype" type="undefined" from="gridx/modules/Bar"><summary>&lt;p>gridx/modules/Bar&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This is a general-purpose bar for gridx. It can be configured to hold various plugins,
such as pager, pageSizer, gotoPageButton, summary, quickFilter, toobar, etc.&lt;/p>
</summary></object><object location="gridx/modules/BidiSupport" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="module" scope="prototype" type="undefined" from="gridx/modules/BidiSupport"><summary>&lt;p>gridx/modules/_BidiSupport&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getTextDir" scope="prototype" type="function" from="gridx/modules/BidiSupport"><parameters><parameter name="colId" type="undefined" usage="required"/><parameter name="text" type="undefined" usage="required"/></parameters><return-types/></method><method name="getTextDirStyle" scope="prototype" type="function" from="gridx/modules/BidiSupport"><parameters><parameter name="colId" type="undefined" usage="required"/><parameter name="text" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Returns input text direction related attributes.&lt;/p>
</summary></method><method name="enforceTextDirWithUcc" scope="prototype" type="function" from="gridx/modules/BidiSupport"><parameters><parameter name="colId" type="undefined" usage="required"/><parameter name="text" type="undefined" usage="required"><summary>&lt;p>The text to be wrapped.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Wraps by UCC (Unicode control characters) option&amp;#39;s text according to textDir&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Module that deals with BIDI, special with the auto
direction if needed without changing the GUI direction.&lt;/p>
</summary><description>&lt;p>There&amp;#39;s a special need for displaying BIDI text in rtl direction
in ltr GUI, sometimes needed auto support.
In creation of widget, if it&amp;#39;s want to activate this class,
the widget should define the &amp;quot;textDir&amp;quot;.
See for reference:  &lt;a href=&quot;http://w3-03.ibm.com/globalization/page/publish/4353&quot;>http://w3-03.ibm.com/globalization/page/publish/4353&lt;/a>&lt;/p>
</description></object><object location="gridx/modules/Dod" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="useAnimation" scope="prototype" type="Boolean" from="gridx/modules/Dod"><summary>&lt;p>Indicates whether to use animation (slide) when showing/hiding the detail part.&lt;/p>
</summary></property><property name="duration" scope="prototype" type="Number" from="gridx/modules/Dod"><summary>&lt;p>The time used to play the animation.&lt;/p>
</summary></property><property name="defaultShow" scope="prototype" type="boolean" from="gridx/modules/Dod"/><property name="showExpando" scope="prototype" type="boolean" from="gridx/modules/Dod"/><property name="autoClose" scope="prototype" type="Boolean" from="gridx/modules/Dod"><summary>&lt;p>Indicates whether the detail part should be closed automatically when another row&amp;#39;s detail part is shown.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="show" scope="prototype" type="function" from="gridx/modules/Dod"><parameters><parameter name="row" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Show the detail part of a row, if this row has a detail part.
Use animation (slide the detail part out) if useAnimation is true.
Nothing happens if rowId is not valid or the row does not has a detail part.&lt;/p>
</summary></method><method name="hide" scope="prototype" type="function" from="gridx/modules/Dod"><parameters><parameter name="row" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Hide the detail part of a row, if this row has a detail part.
Use animation (slide the detail part in) if useAnimation is true.
Nothing happens if rowId is not valid or the row does not has a detail part.&lt;/p>
</summary></method><method name="toggle" scope="prototype" type="function" from="gridx/modules/Dod"><parameters><parameter name="row" type="undefined" usage="required"/></parameters><return-types/></method><method name="refresh" scope="prototype" type="function" from="gridx/modules/Dod"><parameters><parameter name="row" type="undefined" usage="required"/></parameters><return-types/></method><method name="isShown" scope="prototype" type="function" from="gridx/modules/Dod"><parameters><parameter name="row" type="undefined" usage="required"/></parameters><return-types/></method><method name="onShow" scope="prototype" type="function" from="gridx/modules/Dod"><parameters><parameter name="row" type="undefined" usage="required"/></parameters><return-types/></method><method name="onHide" scope="prototype" type="function" from="gridx/modules/Dod"><parameters><parameter name="row" type="undefined" usage="required"/></parameters><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Details on demand.&lt;/p>
</summary></object><object location="gridx/modules/IndirectSelect" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="all" scope="prototype" type="Boolean" from="gridx/modules/IndirectSelect"><summary>&lt;p>Whether the &amp;quot;select all&amp;quot; checkbox is allowed to appear.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module shows a checkbox(or radiobutton) on the row header when row selection is used.&lt;/p>
</summary><description>&lt;p>This module relies on an implementation of the RowHeader module, and an implementation of
the SelectRow module.
This module will check whether the SelectRow module provides the functionality of &amp;quot;select rows by index&amp;quot; 
(which means the &amp;quot;selectByIndex&amp;quot; method exists). If so, a &amp;quot;select all&amp;quot; checkbox can be provided 
in the header node of the row header column.
This module will also check whether the SelectRow module is configured to &amp;quot;single selection&amp;quot; mode
(which means the &amp;quot;multiple&amp;quot; attribute is set to false). If so, radio button instead of checkbox
will be used in row headers.&lt;/p>
</description></object><object location="gridx/modules/RowHeader" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="width" scope="prototype" type="String" from="gridx/modules/RowHeader"><summary>&lt;p>The width (CSS value) of a row header.&lt;/p>
</summary></property><property name="headerProvider" scope="prototype" type="Function" from="gridx/modules/RowHeader"><summary>&lt;p>A functionn that returns an HTML string to fill the header cell of row headers.&lt;/p>
</summary></property><property name="cellProvider" scope="prototype" type="Function" from="gridx/modules/RowHeader"><summary>&lt;p>A function that returns an HTML string to fill the body cells of row headers.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="onMoveToRowHeaderCell" scope="prototype" type="function" from="gridx/modules/RowHeader" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when focus is moved to a row header using keyboard.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This modules provides a header before each row.&lt;/p>
</summary><description>&lt;p>Row header can be used as a UI handler for row selection, especially when
cell selection is turned on and selectRowTriggerOnCell is turned off.
It can also be used as a place to hold the checkbox/radiobutton for IndirectSelect&lt;/p>
</description></object><object location="gridx/modules/IndirectSelectColumn" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="position" scope="prototype" type="number" from="gridx/modules/IndirectSelectColumn"/><property name="width" scope="prototype" type="string" from="gridx/modules/IndirectSelectColumn"/><property name="all" scope="prototype" type="boolean" from="gridx/modules/IndirectSelectColumn"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Provide a check box (or radio button) column to select rows.&lt;/p>
</summary></object><object location="gridx/modules/Menu" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="context" scope="prototype" type="__MenuContext" from="gridx/modules/Menu"><summary>&lt;p>An object representing the current context when user triggers a context menu.
This property is updated everytime a menu of grid is popped up.
Users can refer to this in their menu action handlers by grid.menu.context.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="bind" scope="prototype" type="function" from="gridx/modules/Menu"><parameters><parameter name="menu" type="undefined" usage="required"><summary>&lt;p>The menu to be binded.&lt;/p>
</summary></parameter><parameter name="args" type="__MenuArgs" usage="required"><summary>&lt;p>Indicates how to bind the menu&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Bind a memu to grid, according to the provided args&lt;/p>
</summary></method><method name="unbind" scope="prototype" type="function" from="gridx/modules/Menu"><parameters><parameter name="menu" type="undefined" usage="required"><summary>&lt;p>The menu to be unbinded.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Unbind a menu from grid.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins></object><object location="gridx/modules/NestedSort" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getSortData" scope="prototype" type="function" from="gridx/modules/NestedSort"><parameters/><return-types/></method><method name="sort" scope="prototype" type="function" from="gridx/modules/NestedSort"><parameters><parameter name="sortData" type="undefined" usage="required"/></parameters><return-types/></method><method name="isSorted" scope="prototype" type="function" from="gridx/modules/NestedSort"><parameters><parameter name="colId" type="undefined" usage="required"/></parameters><return-types/></method><method name="clear" scope="prototype" type="function" from="gridx/modules/NestedSort"><parameters/><return-types/><summary>&lt;p>Clear the sorting state&lt;/p>
</summary></method><method name="isSortable" scope="prototype" type="function" from="gridx/modules/NestedSort"><parameters><parameter name="colId" type="undefined" usage="required"/></parameters><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Sort multiple columns in a nested way.&lt;/p>
</summary></object><object location="gridx/modules/Pagination" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="pageSize" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The current page size&lt;/p>
</return-description><summary>&lt;p>Get current page size&lt;/p>
</summary></method><method name="isAll" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>Whether the grid is showing all rows.&lt;/p>
</return-description><summary>&lt;p>Check if the grid is currently showing all rows (page size set to 0).&lt;/p>
</summary></method><method name="pageCount" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The current count of pages.&lt;/p>
</return-description><summary>&lt;p>Get the current count of pages.&lt;/p>
</summary></method><method name="currentPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The index of current page.&lt;/p>
</return-description><summary>&lt;p>Get the index of current page.&lt;/p>
</summary></method><method name="firstIndexInPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="page" type="Integer" usage="required"><summary>&lt;p>The index of a page.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The index of the first row in the page. If page is not valid, return -1.&lt;/p>
</return-description><summary>&lt;p>Get the index of the first row in the given page.&lt;/p>
</summary></method><method name="lastIndexInPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="page" type="Integer" usage="required"><summary>&lt;p>The index of a page&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The index of the last row in the given page.&lt;/p>
</return-description><summary>&lt;p>Get the index of the last row in the given page.&lt;/p>
</summary></method><method name="pageOfIndex" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="index" type="Integer" usage="required"><summary>&lt;p>The row index&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The page index&lt;/p>
</return-description><summary>&lt;p>Get the index of the page that the given row is in.&lt;/p>
</summary></method><method name="indexInPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="index" type="Integer" usage="required"><summary>&lt;p>The row index&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The row index in page&lt;/p>
</return-description><summary>&lt;p>Get the row index in page by overall row index&lt;/p>
</summary></method><method name="filterIndexesInPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="indexes" type="Integer[]" usage="required"><summary>&lt;p>An array of row indexes.&lt;/p>
</summary></parameter><parameter name="page" type="Integer" usage="required"><summary>&lt;p>A page index&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A subset of indexes that appear in the given page.&lt;/p>
</return-description><summary>&lt;p>Filter out the indexes that are in the given page.&lt;/p>
</summary></method><method name="gotoPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="page" type="Integer" usage="required"><summary>&lt;p>A page index&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Set the current page&lt;/p>
</summary></method><method name="setPageSize" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="size" type="Integer" usage="required"><summary>&lt;p>The new page size &lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Set page size (count of rows in one page)&lt;/p>
</summary></method><method name="onSwitchPage" scope="prototype" type="function" from="gridx/modules/Pagination" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when switched to another page.&lt;/p>
</summary></method><method name="onChangePageSize" scope="prototype" type="function" from="gridx/modules/Pagination" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when the page size is changed&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides (logical) pagination functionality for grid.&lt;/p>
</summary><description>&lt;p>This module does not include any UI buttons for pagination, so that various
kinds of pagination UI implementations can benifit from this module.&lt;/p>
</description></object><object location="gridx/modules/Persist" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="enabled" scope="prototype" type="Boolean" from="gridx/modules/Persist"><summary>&lt;p>Whether this module is enabled (also means whether all registered features are persistable).&lt;/p>
</summary></property><property name="options" scope="prototype" type="null" from="gridx/modules/Persist"><summary>&lt;p>Options meaningful to the persist mechanism. By default it mean the cookie options.&lt;/p>
</summary></property><property name="key" scope="prototype" type="String" from="gridx/modules/Persist"><summary>&lt;p>This is the storage key of this grid. If not provided (by default), the grid id is used as the key.
This property is essential when a grid with a different id wants to load from this storage.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="put" scope="prototype" type="function" from="gridx/modules/Persist"><parameters><parameter name="key" type="String" usage="required"><summary>&lt;p>The persist key of this grid.&lt;/p>
</summary></parameter><parameter name="value" type="Object" usage="required"><summary>&lt;p>A JSON object, containing everything we want to persist for this grid.&lt;/p>
</summary></parameter><parameter name="options" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>This is NOT a public method, but users can provide their own to override it.
This function is called when finally saving things into some kind of storage.&lt;/p>
</summary></method><method name="get" scope="prototype" type="function" from="gridx/modules/Persist"><parameters><parameter name="key" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>This is NOT a public method, but users can provide their own to override it.
This function is called when loading things from storage.&lt;/p>
</summary></method><method name="registerAndLoad" scope="prototype" type="function" from="gridx/modules/Persist"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>A unique name of the feature to be persisted.&lt;/p>
</summary></parameter><parameter name="saver" type="undefined" usage="required"><summary>&lt;p>A function to be called when persisting the grid.&lt;/p>
</summary></parameter><parameter name="scope" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Register a feature to be persisted, and then load (return) its contents.&lt;/p>
</summary></method><method name="features" scope="prototype" type="function" from="gridx/modules/Persist"><parameters/><return-types/><summary>&lt;p>Get the names of all the persistable features.
These names can be used in enable(), disable() or isEnabled() methods.&lt;/p>
</summary></method><method name="enable" scope="prototype" type="function" from="gridx/modules/Persist"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Name of a feature.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Enable persistance of the given feature, that is, will persist this feature when the save function
is called. If name is not provided (undefined or null), then enable all registered features.&lt;/p>
</summary></method><method name="disable" scope="prototype" type="function" from="gridx/modules/Persist"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Name of a feature.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Disable persistance of the given feature, that is, will NOT persist this feature when the save
function is called. If name is not provided (undefined or null), then disable all registered features.&lt;/p>
</summary></method><method name="isEnabled" scope="prototype" type="function" from="gridx/modules/Persist"><parameters><parameter name="name" type="String" usage="required"><summary>&lt;p>Name of a feature. If omitted, means every feature.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Check whether a feature is enabled or not.&lt;/p>
</summary></method><method name="save" scope="prototype" type="function" from="gridx/modules/Persist"><parameters/><return-types/><summary>&lt;p>Save all the enabled features.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Provide a mechanism to persist various grid features when the grid is destroyed,
so that when a new grid with the same id (or the same persist key) is created,
all these features will be restored.
By default use cookie, but users can also provide custom put and get functions.
Note: since dojox.storage is still experimental, and with HTML5 we will hardly need
things like gears or behavior storage, so we aren&amp;#39;t supporting dojox.storage by default.&lt;/p>
</summary></object><object location="gridx/modules/Printer" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="print" scope="prototype" type="function" from="gridx/modules/Printer"><parameters><parameter name="args" type="Object" usage="required"><summary>&lt;p>Please refer to &lt;code>grid.printer.__PrinterArgs&lt;/code>&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when the export process is completed.&lt;/p>
</return-description><summary>&lt;p>Print grid contents.&lt;/p>
</summary></method><method name="toHTML" scope="prototype" type="function" from="gridx/modules/Printer"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides the API to print grid contents or provide print preview&lt;/p>
</summary><description>&lt;p>Deprecated. Please use gridx/support/printer instead.&lt;/p>
</description></object><object location="gridx/support/printer" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="gridx/support/printer"><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="args" type="Object" usage="required"><summary>&lt;p>Please refer to &lt;code>grid.printer.__PrinterArgs&lt;/code>&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>&lt;p>A deferred object indicating when the export process is completed.&lt;/p>
</return-description><summary>&lt;p>Print grid contents.&lt;/p>
</summary></method><method name="toHTML" scope="normal" type="function" from="gridx/support/printer"><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="args" type="undefined" usage="required"/></parameters><return-types><return-type type="instance"/></return-types></method></methods><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="args" type="Object" usage="required"><summary>&lt;p>Please refer to &lt;code>grid.printer.__PrinterArgs&lt;/code>&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>&lt;p>A deferred object indicating when the export process is completed.&lt;/p>
</return-description><summary>&lt;p>Print grid contents.&lt;/p>
</summary></object><object location="gridx/support/exporter/toTable" type="function"><properties><property name="writer" scope="normal" type="object" from="gridx/support/exporter/toTable"/></properties><methods><method name="constructor" scope="prototype" type="function" from="gridx/support/exporter/toTable"><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="args" type="__TableExportArgs" usage="optional"><summary>&lt;p>The args to configure the export result and the export process.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>&lt;p>A deferred object indicating when the export process is completed,
and then pass the exported HTML table (as string) to callbacks.&lt;/p>
</return-description><summary>&lt;p>Export the grid contents to HTML table according to the given args.&lt;/p>
</summary></method></methods><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="args" type="__TableExportArgs" usage="optional"><summary>&lt;p>The args to configure the export result and the export process.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>&lt;p>A deferred object indicating when the export process is completed,
and then pass the exported HTML table (as string) to callbacks.&lt;/p>
</return-description><summary>&lt;p>Export the grid contents to HTML table according to the given args.&lt;/p>
</summary></object><object location="gridx/support/exporter/toTable.writer" type="object"><properties/><methods><method name="_cellattrs" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="args" type="undefined" usage="required"/><parameter name="col" type="undefined" usage="required"/><parameter name="cellContent" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="initialize" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters><parameter name="args" type="__TableExportArgs" usage="required"/></parameters><return-types/></method><method name="beforeHeader" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters/><return-types/></method><method name="handleHeaderCell" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters><parameter name="context" type="__ExportContext" usage="required"/><parameter name="args" type="__TableExportArgs" usage="required"/></parameters><return-types/></method><method name="afterHeader" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters/><return-types/></method><method name="beforeBody" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters/><return-types/></method><method name="beforeRow" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters><parameter name="context" type="__ExportContext" usage="required"/></parameters><return-types/></method><method name="handleCell" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters><parameter name="context" type="__ExportContext" usage="required"/><parameter name="args" type="__TableExportArgs" usage="required"/></parameters><return-types/></method><method name="afterRow" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters/><return-types/></method><method name="afterBody" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters/><return-types/></method><method name="getResult" scope="normal" type="function" from="gridx/support/exporter/toTable"><parameters/><return-types><return-type type="undefined"/></return-types></method></methods></object><object location="gridx/support/exporter/exporter" type="function"><properties/><methods><method name="constructor" scope="prototype" type="function" from="gridx/support/exporter/exporter"><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="writer" type="undefined" usage="required"/><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:
&lt;/p>
</description></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Go through the grid using the given args and writer implementation.
Return a dojo.Deferred object. Users can cancel and see progress 
of the exporting process.
Pass the exported result to the callback function of the Deferred object.&lt;/p>
</summary></method></methods><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="writer" type="undefined" usage="required"/><parameter name="args" type="Object" usage="required"><description>&lt;p>An object with the following properties:
&lt;/p>
</description></parameter></parameters><return-types><return-type type="instance"/></return-types><summary>&lt;p>Go through the grid using the given args and writer implementation.
Return a dojo.Deferred object. Users can cancel and see progress 
of the exporting process.
Pass the exported result to the callback function of the Deferred object.&lt;/p>
</summary></object><object location="gridx/modules/RowLock" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="lock" scope="prototype" type="function" from="gridx/modules/RowLock"><parameters><parameter name="count" type="undefined" usage="required"/></parameters><return-types/></method><method name="unlock" scope="prototype" type="function" from="gridx/modules/RowLock"><parameters/><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Lock up some rows at the top of the grid body, so that they don&amp;#39;t scroll vertically.&lt;/p>
</summary><description>&lt;p>This module is not compatible with VirtualVScroller.&lt;/p>
</description></object><object location="gridx/modules/SummaryBar" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Add summary bar to the bottom of grid.&lt;/p>
</summary><description>&lt;p>Add summary based on Bar module. This module is only for conveniency and backward compatibility.
Using Bar module directly is recommended.&lt;/p>
</description></object><object location="gridx/support/Summary" type="constructor" classlike="true"><properties><property name="grid" scope="prototype" type="null" from="gridx/support/Summary"/></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/Summary"><parameters/><return-types/></method></methods><summary>&lt;p>Show total row count and selected row count.&lt;/p>
</summary></object><object location="gridx/modules/TitleBar" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="label" scope="prototype" type="string" from="gridx/modules/TitleBar"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="setLabel" scope="prototype" type="function" from="gridx/modules/TitleBar"><parameters/><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Add title bar for grid.&lt;/p>
</summary></object><object location="gridx/modules/ToolBar" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="widget" scope="prototype" type="null" from="gridx/modules/ToolBar"/><property name="domNode" scope="prototype" type="null" from="gridx/modules/ToolBar"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Add toolbar on top of grid.&lt;/p>
</summary><description>&lt;p>Add toolbar based on Bar module. This module is only for conveniency and backward compatibility.
Using Bar module directly is recommended.&lt;/p>
</description></object><object location="gridx/modules/TouchVScroller" type="constructor" classlike="true" superclass="gridx/modules/VScroller"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="scrollToRow" scope="prototype" type="function" from="gridx/modules/VScroller"><parameters><parameter name="rowVisualIndex" type="Integer" usage="required"><summary>&lt;p>The visual index of the row&lt;/p>
</summary></parameter><parameter name="toTop" type="Boolean" usage="optional"><summary>&lt;p>If set this to true, the grid will try to scroll the required row to the top of the view.
Otherwise, the grid will stop scrolling as soon as the row is visible.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when the scrolling process is finished. This will be useful
when using lazy-loading and lazy-rendering.&lt;/p>
</return-description><summary>&lt;p>Scroll the grid until the required row is in view.&lt;/p>
</summary><description>&lt;p>This job will be an asynchronous one if the lazy-loading and lazy-rendering are used.&lt;/p>
</description></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/VScroller"/></mixins><summary>&lt;p>A vertical scroller only for touch devices.&lt;/p>
</summary><description>&lt;p>Using dojox/mobile/scrollable, and no lazy-rendering (all rows are rendered out).&lt;/p>
</description></object><object location="gridx/modules/Tree" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="nested" scope="prototype" type="Boolean" from="gridx/modules/Tree"><summary>&lt;p>If set to true, the tree nodes can be shown in nested mode.&lt;/p>
</summary></property><property name="expandoPadding" scope="prototype" type="Integer" from="gridx/modules/Tree"><summary>&lt;p>The padding added for each level of expando. Unit is pixel. Default to 18.&lt;/p>
</summary></property><property name="expandLevel" scope="prototype" type="Integer" from="gridx/modules/Tree"><summary>&lt;p>The maximum allowed expand level of this tree grid.
If less than 1, then this is not a tree grid at all.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="onExpand" scope="prototype" type="function" from="gridx/modules/Tree" tags="callback"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The ID of the expanded row&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when a row is expanded.&lt;/p>
</summary></method><method name="onCollapse" scope="prototype" type="function" from="gridx/modules/Tree" tags="callback"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The ID of the collapsed row.&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when a row is collapsed.&lt;/p>
</summary></method><method name="canExpand" scope="prototype" type="function" from="gridx/modules/Tree"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>Whether the row can be expanded.&lt;/p>
</return-description><summary>&lt;p>Check whether a row can be expanded.&lt;/p>
</summary></method><method name="isExpanded" scope="prototype" type="function" from="gridx/modules/Tree"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>Whether the row is expanded.&lt;/p>
</return-description><summary>&lt;p>Check whether a row is already expanded.&lt;/p>
</summary></method><method name="expand" scope="prototype" type="function" from="gridx/modules/Tree"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter><parameter name="skipUpdateBody" type="Boolean" usage="required"><summary>&lt;p>If set to true the grid will not automatically refresh itself after this method,
so that several grid operations can be executed altogether.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating whether this expanding process has completed.&lt;/p>
</return-description><summary>&lt;p>Expand the row.&lt;/p>
</summary></method><method name="collapse" scope="prototype" type="function" from="gridx/modules/Tree"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter><parameter name="skipUpdateBody" type="Boolean" usage="required"><summary>&lt;p>If set to true the grid will not automatically refresh itself after this method,
so that several grid operations can be executed altogether.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating whether this collapsing process has completed.&lt;/p>
</return-description><summary>&lt;p>Collapse a row.&lt;/p>
</summary></method><method name="expandRecursive" scope="prototype" type="function" from="gridx/modules/Tree"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter><parameter name="skipUpdateBody" type="Boolean" usage="required"><summary>&lt;p>If set to true the grid will not automatically refresh itself after this method,
so that several grid operations can be executed altogether.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating whether this expanding process has completed.&lt;/p>
</return-description><summary>&lt;p>Recursively expand a row and all its descendants.&lt;/p>
</summary></method><method name="collapseRecursive" scope="prototype" type="function" from="gridx/modules/Tree"><parameters><parameter name="id" type="String" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter><parameter name="skipUpdateBody" type="Boolean" usage="required"><summary>&lt;p>If set to true the grid will not automatically refresh itself after this method,
so that several grid operations can be executed altogether.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating whether this collapsing process has completed.&lt;/p>
</return-description><summary>&lt;p>Recursively collapse a row recursively and all its descendants.&lt;/p>
</summary></method><method name="refresh" scope="prototype" type="function" from="gridx/modules/Tree"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>A Deferred object indicating when this process ends.&lt;/p>
</return-description><summary>&lt;p>When the row order are changed or rows are filtered, the expand info recorded here will
be invalid. This method refreshes the expand info by logically re-open all expanded rows,
and then refresh the grid body.
When this method is called, no need to call grid.body.refresh() anymore.&lt;/p>
</summary></method><method name="getRowInfoByVisualIndex" scope="prototype" type="function" from="gridx/modules/Tree" private="true" tags="private"><parameters><parameter name="visualIndex" type="Integer" usage="required"/><parameter name="rootStart" type="Integer" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A row info object&lt;/p>
</return-description><summary>&lt;p>Get row info (including row index, row id, parent id, etc) by row visual index.&lt;/p>
</summary></method><method name="getVisualIndexByRowInfo" scope="prototype" type="function" from="gridx/modules/Tree" private="true" tags="private"><parameters><parameter name="parentId" type="undefined" usage="required"/><parameter name="rowIndex" type="undefined" usage="required"/><parameter name="rootStart" type="undefined" usage="required"/></parameters><return-types/></method><method name="getVisualSize" scope="prototype" type="function" from="gridx/modules/Tree" private="true" tags="private"><parameters><parameter name="start" type="undefined" usage="required"/><parameter name="count" type="undefined" usage="required"/><parameter name="parentId" type="undefined" usage="required"/></parameters><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Tree Grid module.&lt;/p>
</summary><description>&lt;p>This module is used for creation, destruction and management of the Tree Grid.
There are two kind of Tree Grid: columnar or nested, it will be indicated by
the argument &lt;code>type&lt;/code>, and the layout of the TreeGrid will be defined by extended
&lt;code>structure&lt;/code> argument.&lt;/p>
</description><examples><example>&lt;p>For the columnar Tree Grid, the column which is expandable is indicated by the 
new added attribute &lt;code>expandField&lt;/code>, and the value of the &lt;code>expandField&lt;/code> is one 
or more attribute names (attributes in the meta data) that specify that item&amp;#39;s 
children.
See the quick sample below:

&lt;/p>
&lt;p>sample of data source

&lt;/p>
&lt;pre>&lt;code>{ identifier: &amp;#39;name&amp;#39;,
  label: &amp;#39;name&amp;#39;,
  items: [
    { name:&amp;#39;Africa&amp;#39;, type:&amp;#39;continent&amp;#39;, children: [
        { name:&amp;#39;Egypt&amp;#39;, type:&amp;#39;country&amp;#39; }, 
        { name:&amp;#39;Kenya&amp;#39;, type:&amp;#39;country&amp;#39;, children:[
            { name:&amp;#39;Nairobi&amp;#39;, type:&amp;#39;city&amp;#39;, adults: 70400, popnum: 2940911 },
            { name:&amp;#39;Mombasa&amp;#39;, type:&amp;#39;city&amp;#39;, adults: 294091, popnum: 707400 } ]
        },
        { name:&amp;#39;Sudan&amp;#39;, type:&amp;#39;country&amp;#39;, children:
            { name:&amp;#39;Khartoum&amp;#39;, type:&amp;#39;city&amp;#39;, adults: 480293, popnum: 1200394 } 
        } ]
    },
    { name:&amp;#39;Asia&amp;#39;, type:&amp;#39;continent&amp;#39;, children:[
        { name:&amp;#39;China&amp;#39;, type:&amp;#39;country&amp;#39; },
        { name:&amp;#39;India&amp;#39;, type:&amp;#39;country&amp;#39; },
        { name:&amp;#39;Russia&amp;#39;, type:&amp;#39;country&amp;#39; },
        { name:&amp;#39;Mongolia&amp;#39;, type:&amp;#39;country&amp;#39; } ]
    },
    { name:&amp;#39;Australia&amp;#39;, type:&amp;#39;continent&amp;#39;, population:&amp;#39;21 million&amp;#39;, children:
        { name:&amp;#39;Commonwealth of Australia&amp;#39;, type:&amp;#39;country&amp;#39;, population:&amp;#39;21 million&amp;#39;}
    } ]
}&lt;/code>&lt;/pre>
&lt;p>define the grid structure

&lt;/p>
&lt;pre>&lt;code>var structure = [
    {name: &amp;quot;Name&amp;quot;, field: &amp;quot;name&amp;quot;, expandLevel: &amp;#39;all&amp;#39;},
    {name: &amp;quot;Type&amp;quot;, field: &amp;quot;type&amp;quot;},
    {name: &amp;quot;Population&amp;quot;, field: &amp;quot;population&amp;quot;}
];&lt;/code>&lt;/pre>
&lt;p>For the nested TreeGrid, there could be more than one column can be expanded, 
so the structure might be a little more complicated. There is ONLY one attribute
name can be assigned to the &lt;code>expandField&lt;/code> as children, and there would be a 
attribute called &lt;code>nestedLevel&lt;/code> to specify the hierarchy of the column.
A quick sample:

&lt;/p>
&lt;p>sample of data source


&lt;/p>
&lt;pre>&lt;code>{ identifier: &amp;#39;id&amp;#39;,
  items: [
    { id: &amp;quot;1&amp;quot;, playername: &amp;quot;Player 1&amp;quot;, seasons: [
        { id: &amp;quot;2&amp;quot;, seasonindex: &amp;quot;Season 1&amp;quot;, games: [
            { id: &amp;quot;3&amp;quot;, gameindex: &amp;quot;Game 1&amp;quot;, quarters: [
                {id: &amp;quot;4&amp;quot;, point: &amp;quot;3&amp;quot;, rebound: &amp;quot;3&amp;quot;, assistant: &amp;quot;1&amp;quot;},
                {id: &amp;quot;5&amp;quot;, point: &amp;quot;5&amp;quot;, rebound: &amp;quot;0&amp;quot;, assistant: &amp;quot;0&amp;quot;},
                {id: &amp;quot;6&amp;quot;, point: &amp;quot;0&amp;quot;, rebound: &amp;quot;1&amp;quot;, assistant: &amp;quot;3&amp;quot;},
                {id: &amp;quot;7&amp;quot;, point: &amp;quot;2&amp;quot;, rebound: &amp;quot;2&amp;quot;, assistant: &amp;quot;0&amp;quot;} ]
            },
            { id: &amp;quot;8&amp;quot;, gameindex: &amp;quot;Game 2&amp;quot;, quarters: [
                {id: &amp;quot;9&amp;quot;, point: &amp;quot;3&amp;quot;, rebound: &amp;quot;0&amp;quot;, assistant: &amp;quot;2&amp;quot;},
                {id: &amp;quot;10&amp;quot;, point: &amp;quot;0&amp;quot;, rebound: &amp;quot;4&amp;quot;, assistant: &amp;quot;1&amp;quot;},
                {id: &amp;quot;11&amp;quot;, point: &amp;quot;5&amp;quot;, rebound: &amp;quot;0&amp;quot;, assistant: &amp;quot;1&amp;quot;},
                {id: &amp;quot;12&amp;quot;, point: &amp;quot;10&amp;quot;, rebound: &amp;quot;2&amp;quot;, assistant: &amp;quot;0&amp;quot;} ]
            } ]
        },
        { id: &amp;quot;13&amp;quot;, seasonindex: &amp;quot;Season 2&amp;quot; } ]
    } ]
}&lt;/code>&lt;/pre>
&lt;p>define the tree grid type

&lt;/p>
&lt;pre>&lt;code>treeNested: true;&lt;/code>&lt;/pre>
&lt;p>define the grid structure

&lt;/p>
&lt;pre>&lt;code>var structure = [
    {name: &amp;quot;Player&amp;quot;, field: &amp;quot;playername&amp;quot;, expandLevel: 1},
    {name: &amp;quot;Season&amp;quot;, field: &amp;quot;seasonindex&amp;quot;, expandLevel: 2},
    {name: &amp;quot;Game&amp;quot;, field: &amp;quot;gameindex&amp;quot;, expandLevel: 3},
    {name: &amp;quot;Point&amp;quot;, field: &amp;quot;point&amp;quot;},
    {name: &amp;quot;Rebound&amp;quot;, field: &amp;quot;rebound&amp;quot;},
    {name: &amp;quot;Assistant&amp;quot;, field: &amp;quot;assistant&amp;quot;}
];&lt;/code>&lt;/pre>
</example></examples></object><object location="gridx/modules/VirtualVScroller" type="constructor" classlike="true" superclass="gridx/modules/VScroller"><properties><property name="buffSize" scope="prototype" type="Integer" from="gridx/modules/VirtualVScroller"><summary>&lt;p>The count row nodes that should be maintained above/below the grid body viewport.
The total count row nodes consists of the count of rows that are visible, and buffSize * 2.&lt;/p>
</summary></property><property name="lazy" scope="prototype" type="Boolean" from="gridx/modules/VirtualVScroller"><summary>&lt;p>If this argument is set to true, the grid will not fetch data during scrolling.
Instead, it&amp;#39;ll fetch data after the scrolling process is completed (plus a timeout).
This is useful when a large slow server side data store is used, because frequent
data fetch requests are avoided.&lt;/p>
</summary></property><property name="lazyTimeout" scope="prototype" type="Number" from="gridx/modules/VirtualVScroller"><summary>&lt;p>This is the timeout for the &amp;quot;lazy&amp;quot; argument.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="scrollToRow" scope="prototype" type="function" from="gridx/modules/VirtualVScroller" tags="extension"><parameters><parameter name="rowVisualIndex" type="undefined" usage="required"/><parameter name="toTop" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Override VScroller.scrollToRow&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/VScroller"/></mixins><summary>&lt;p>This module implements lazy-rendering when virtically scrolling grid.&lt;/p>
</summary><description>&lt;p>This module takes a DOMNode-based way to implement lazy-rendering.
It tries to remove all the DOMNodes that are out of the grid body viewport,
so that the DOMNodes in grid are always limited to a very small number.&lt;/p>
</description></object><object location="gridx/modules/barPlugins/DropDownPager" type="constructor" classlike="true"><properties><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/DropDownPager"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property><property name="stepperClass" scope="prototype" type="Function" from="gridx/support/DropDownPager"><summary>&lt;p>The constructor of the select widget&lt;/p>
</summary></property><property name="stepperProps" scope="prototype" type="Object" from="gridx/support/DropDownPager"><summary>&lt;p>The properties passed to select widget when creating it.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/DropDownPager"><parameters/><return-types/></method></methods><summary>&lt;p>This grid bar plugin is to switch pages using select widget.&lt;/p>
</summary></object><object location="gridx/support/DropDownPager" type="constructor" classlike="true"><properties><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/DropDownPager"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property><property name="stepperClass" scope="prototype" type="Function" from="gridx/support/DropDownPager"><summary>&lt;p>The constructor of the select widget&lt;/p>
</summary></property><property name="stepperProps" scope="prototype" type="Object" from="gridx/support/DropDownPager"><summary>&lt;p>The properties passed to select widget when creating it.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/DropDownPager"><parameters/><return-types/></method></methods><summary>&lt;p>This grid bar plugin is to switch pages using select widget.&lt;/p>
</summary></object><object location="gridx/modules/barPlugins/DropDownSizer" type="constructor" classlike="true"><properties><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/DropDownSizer"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property><property name="sizes" scope="prototype" type="Integer[]" from="gridx/support/DropDownSizer"><summary>&lt;p>An array of available page sizes. Non-positive number means &amp;quot;all&amp;quot;&lt;/p>
</summary></property><property name="sizerClass" scope="prototype" type="Function" from="gridx/support/DropDownSizer"><summary>&lt;p>The constructor of the select widget&lt;/p>
</summary></property><property name="sizerProps" scope="prototype" type="Object" from="gridx/support/DropDownSizer"><summary>&lt;p>The properties passed to select widget when creating it.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/DropDownSizer"><parameters/><return-types/></method></methods><summary>&lt;p>This grid bar plugin is to switch page sizes using select widget.&lt;/p>
</summary></object><object location="gridx/support/DropDownSizer" type="constructor" classlike="true"><properties><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/DropDownSizer"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property><property name="sizes" scope="prototype" type="Integer[]" from="gridx/support/DropDownSizer"><summary>&lt;p>An array of available page sizes. Non-positive number means &amp;quot;all&amp;quot;&lt;/p>
</summary></property><property name="sizerClass" scope="prototype" type="Function" from="gridx/support/DropDownSizer"><summary>&lt;p>The constructor of the select widget&lt;/p>
</summary></property><property name="sizerProps" scope="prototype" type="Object" from="gridx/support/DropDownSizer"><summary>&lt;p>The properties passed to select widget when creating it.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/DropDownSizer"><parameters/><return-types/></method></methods><summary>&lt;p>This grid bar plugin is to switch page sizes using select widget.&lt;/p>
</summary></object><object location="gridx/modules/barPlugins/GotoPageButton" type="constructor" classlike="true" superclass="gridx/support/_LinkPageBase"><properties><property name="dialogClass" scope="prototype" type="object" from="gridx/support/GotoPageButton"/><property name="buttonClass" scope="prototype" type="object" from="gridx/support/GotoPageButton"/><property name="numberTextBoxClass" scope="prototype" type="object" from="gridx/support/GotoPageButton"/><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/_LinkPageBase"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property></properties><methods><method name="gotoPagePane" scope="prototype" type="constructor" from="gridx/support/GotoPageButton"><parameters/><return-types/></method><method name="refresh" scope="prototype" type="function" from="gridx/support/GotoPageButton"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/support/_LinkPageBase"/></mixins></object><object location="gridx/support/GotoPageButton" type="constructor" classlike="true" superclass="gridx/support/_LinkPageBase"><properties><property name="dialogClass" scope="prototype" type="object" from="gridx/support/GotoPageButton"/><property name="buttonClass" scope="prototype" type="object" from="gridx/support/GotoPageButton"/><property name="numberTextBoxClass" scope="prototype" type="object" from="gridx/support/GotoPageButton"/><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/_LinkPageBase"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property></properties><methods><method name="gotoPagePane" scope="prototype" type="constructor" from="gridx/support/GotoPageButton"><parameters/><return-types/></method><method name="refresh" scope="prototype" type="function" from="gridx/support/GotoPageButton"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/support/_LinkPageBase"/></mixins></object><object location="gridx/support/_LinkPageBase" type="constructor" classlike="true"><properties><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/_LinkPageBase"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property></properties><methods/></object><object location="gridx/support/GotoPagePane" type="constructor" classlike="true"><properties/><methods/></object><object location="gridx/modules/barPlugins/LinkPager" type="constructor" classlike="true" superclass="gridx/support/_LinkPageBase"><properties><property name="visibleSteppers" scope="prototype" type="Integer" from="gridx/support/LinkPager"><summary>&lt;p>Number of visible page steppers. If invalid, default to 3.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/_LinkPageBase"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/LinkPager"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/support/_LinkPageBase"/></mixins><summary>&lt;p>This is a grid bar plugin to switch pages for grid using link buttons.&lt;/p>
</summary></object><object location="gridx/support/LinkPager" type="constructor" classlike="true" superclass="gridx/support/_LinkPageBase"><properties><property name="visibleSteppers" scope="prototype" type="Integer" from="gridx/support/LinkPager"><summary>&lt;p>Number of visible page steppers. If invalid, default to 3.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/_LinkPageBase"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/LinkPager"><parameters/><return-types/></method></methods><mixins><mixin location="gridx/support/_LinkPageBase"/></mixins><summary>&lt;p>This is a grid bar plugin to switch pages for grid using link buttons.&lt;/p>
</summary></object><object location="gridx/modules/barPlugins/LinkSizer" type="constructor" classlike="true" superclass="gridx/support/_LinkPageBase"><properties><property name="sizeSeparator" scope="prototype" type="string" from="gridx/support/LinkSizer"/><property name="sizes" scope="prototype" type="Integer[]" from="gridx/support/LinkSizer"><summary>&lt;p>An array of available page sizes. Non-positive number means &amp;quot;all&amp;quot;&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/_LinkPageBase"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/LinkSizer"><parameters/><return-types/><summary>&lt;p>Refresh the UI using current arguments.&lt;/p>
</summary></method></methods><mixins><mixin location="gridx/support/_LinkPageBase"/></mixins><summary>&lt;p>This is a grid bar plugin that can be used to switch page sizes using link buttons.&lt;/p>
</summary></object><object location="gridx/support/LinkSizer" type="constructor" classlike="true" superclass="gridx/support/_LinkPageBase"><properties><property name="sizeSeparator" scope="prototype" type="string" from="gridx/support/LinkSizer"/><property name="sizes" scope="prototype" type="Integer[]" from="gridx/support/LinkSizer"><summary>&lt;p>An array of available page sizes. Non-positive number means &amp;quot;all&amp;quot;&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/_LinkPageBase"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/LinkSizer"><parameters/><return-types/><summary>&lt;p>Refresh the UI using current arguments.&lt;/p>
</summary></method></methods><mixins><mixin location="gridx/support/_LinkPageBase"/></mixins><summary>&lt;p>This is a grid bar plugin that can be used to switch page sizes using link buttons.&lt;/p>
</summary></object><object location="gridx/modules/barPlugins/Summary" type="constructor" classlike="true"><properties><property name="grid" scope="prototype" type="null" from="gridx/support/Summary"/></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/support/Summary"><parameters/><return-types/></method></methods><summary>&lt;p>Show total row count and selected row count.&lt;/p>
</summary></object><object location="gridx/modules/dnd/Avatar" type="constructor" classlike="true"><properties/><methods/><summary>&lt;p>This dnd avatar is in a separated file so it can be (dynamically) overwritten in case of need&lt;/p>
</summary></object><object location="gridx/modules/dnd/Column" type="constructor" classlike="true" superclass="gridx/modules/dnd/_Base"><properties><property name="accept" scope="prototype" type="String[]" from="gridx/modules/dnd/Column"><summary>&lt;p>Can drag in what kind of stuff
For now can not drag in any columns.&lt;/p>
</summary></property><property name="provide" scope="prototype" type="String[]" from="gridx/modules/dnd/Column"><summary>&lt;p>Can drag out what kind of stuff&lt;/p>
</summary></property><property name="delay" scope="prototype" type="Number" from="gridx/modules/dnd/_Base"><summary>&lt;p>The time delay before starting dnd after mouse down.&lt;/p>
</summary></property><property name="enabled" scope="prototype" type="Boolean" from="gridx/modules/dnd/_Base"><summary>&lt;p>Whether this module is enabled.&lt;/p>
</summary></property><property name="canRearrange" scope="prototype" type="Boolean" from="gridx/modules/dnd/_Base"><summary>&lt;p>Whether rearrange within grid using dnd iw allowed.&lt;/p>
</summary></property><property name="copyWhenDragOut" scope="prototype" type="Boolean|Object" from="gridx/modules/dnd/_Base"><summary>&lt;p>When dragging out, whehter to delete in this grid.&lt;/p>
</summary></property><property name="avatar" scope="prototype" type="Function" from="gridx/modules/dnd/_Base"><summary>&lt;p>The avatar used during dnd.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/dnd/_Base"/></mixins><summary>&lt;p>This module provides an implementation of column drag &amp;amp; drop.
It supports column reordering within grid, dragging out of grid, and dragging into grid.&lt;/p>
</summary></object><object location="gridx/modules/dnd/_Base" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="delay" scope="prototype" type="Number" from="gridx/modules/dnd/_Base"><summary>&lt;p>The time delay before starting dnd after mouse down.&lt;/p>
</summary></property><property name="enabled" scope="prototype" type="Boolean" from="gridx/modules/dnd/_Base"><summary>&lt;p>Whether this module is enabled.&lt;/p>
</summary></property><property name="canRearrange" scope="prototype" type="Boolean" from="gridx/modules/dnd/_Base"><summary>&lt;p>Whether rearrange within grid using dnd iw allowed.&lt;/p>
</summary></property><property name="copyWhenDragOut" scope="prototype" type="Boolean|Object" from="gridx/modules/dnd/_Base"><summary>&lt;p>When dragging out, whehter to delete in this grid.&lt;/p>
</summary></property><property name="avatar" scope="prototype" type="Function" from="gridx/modules/dnd/_Base"><summary>&lt;p>The avatar used during dnd.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Base class for dnd modules.&lt;/p>
</summary></object><object location="gridx/modules/dnd/_Dnd" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="_fixFF" scope="prototype" type="function" from="gridx/modules/dnd/_Dnd"><parameters><parameter name="source" type="undefined" usage="required"/></parameters><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins></object><object location="gridx/modules/dnd/Row" type="constructor" classlike="true" superclass="gridx/modules/dnd/_Base"><properties><property name="accept" scope="prototype" type="String[]" from="gridx/modules/dnd/Row"><summary>&lt;p>Can drag in what kind of stuff&lt;/p>
</summary></property><property name="provide" scope="prototype" type="String[]" from="gridx/modules/dnd/Row"><summary>&lt;p>Can drag out what kind of stuff&lt;/p>
</summary></property><property name="delay" scope="prototype" type="Number" from="gridx/modules/dnd/_Base"><summary>&lt;p>The time delay before starting dnd after mouse down.&lt;/p>
</summary></property><property name="enabled" scope="prototype" type="Boolean" from="gridx/modules/dnd/_Base"><summary>&lt;p>Whether this module is enabled.&lt;/p>
</summary></property><property name="canRearrange" scope="prototype" type="Boolean" from="gridx/modules/dnd/_Base"><summary>&lt;p>Whether rearrange within grid using dnd iw allowed.&lt;/p>
</summary></property><property name="copyWhenDragOut" scope="prototype" type="Boolean|Object" from="gridx/modules/dnd/_Base"><summary>&lt;p>When dragging out, whehter to delete in this grid.&lt;/p>
</summary></property><property name="avatar" scope="prototype" type="Function" from="gridx/modules/dnd/_Base"><summary>&lt;p>The avatar used during dnd.&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/dnd/_Base"/></mixins><summary>&lt;p>This module provides an implementation of row drag &amp;amp; drop.
It supports row reordering within grid, dragging out of grid, and dragging into grid.&lt;/p>
</summary></object><object location="gridx/modules/exporter/CSV" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides the API to export grid contents to CSV format string&lt;/p>
</summary></object><object location="gridx/modules/exporter/Exporter" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="_export" scope="prototype" type="function" from="gridx/modules/exporter/Exporter" private="true" tags="private"><parameters><parameter name="writer" type="undefined" usage="required"/><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Go through the grid using the given args and writer implementation.
Return a dojo.Deferred object. Users can cancel and see progress 
of the exporting process.
Pass the exported result to the callback function of the Deferred object.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method><method name="toCSV" scope="normal" type="function" from="gridx/modules/exporter/CSV" extension-module="true"><parameters><parameter name="args" type="__CSVExportArgs" usage="optional"><summary>&lt;p>The args to configure the export result and the export process.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when the export process is completed,
and then pass the exported CSV string to callbacks.&lt;/p>
</return-description><summary>&lt;p>Export the grid contents to CSV according to the given args.
This method should be called through grid.exporter.toCSV();&lt;/p>
</summary></method><method name="toTable" scope="normal" type="function" from="gridx/modules/exporter/Table" extension-module="true"><parameters><parameter name="args" type="Object" usage="optional"><summary>&lt;p>The args to configure the export result and the export process.&lt;/p>
</summary><description>&lt;p>An object with the following properties:

&lt;/p>
&lt;ul>
&lt;li>natualWidth&lt;/li>
&lt;li>columnWidth&lt;/li>
&lt;/ul>
</description></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A deferred object indicating when the export process is completed,
and then pass the exported HTML table (as string) to callbacks.&lt;/p>
</return-description><summary>&lt;p>Export the grid contents to HTML table according to the given args.
This method should be called through grid.exporter.toCSV();&lt;/p>
</summary></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Deprecated.&lt;/p>
</summary></object><object location="gridx/support/exporter/toCSV" type="function"><properties><property name="writer" scope="normal" type="object" from="gridx/support/exporter/toCSV"/></properties><methods><method name="constructor" scope="prototype" type="function" from="gridx/support/exporter/toCSV"><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="args" type="__CSVExportArgs" usage="optional"><summary>&lt;p>The args to configure the export result and the export process.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>&lt;p>A deferred object indicating when the export process is completed,
and then pass the exported CSV string to callbacks.&lt;/p>
</return-description><summary>&lt;p>Export the grid contents to CSV according to the given args.&lt;/p>
</summary></method></methods><parameters><parameter name="grid" type="undefined" usage="required"/><parameter name="args" type="__CSVExportArgs" usage="optional"><summary>&lt;p>The args to configure the export result and the export process.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/><return-type type="undefined"/></return-types><return-description>&lt;p>A deferred object indicating when the export process is completed,
and then pass the exported CSV string to callbacks.&lt;/p>
</return-description><summary>&lt;p>Export the grid contents to CSV according to the given args.&lt;/p>
</summary></object><object location="gridx/support/exporter/toCSV.writer" type="object"><properties/><methods><method name="initialize" scope="normal" type="function" from="gridx/support/exporter/toCSV"><parameters><parameter name="args" type="__CSVExportArgs" usage="required"/></parameters><return-types/></method><method name="beforeHeader" scope="normal" type="function" from="gridx/support/exporter/toCSV"><parameters/><return-types/></method><method name="handleHeaderCell" scope="normal" type="function" from="gridx/support/exporter/toCSV"><parameters><parameter name="context" type="Object" usage="required"><description>&lt;p>An object with the following properties:
&lt;/p>
</description></parameter></parameters><return-types/></method><method name="afterHeader" scope="normal" type="function" from="gridx/support/exporter/toCSV"><parameters/><return-types/></method><method name="beforeRow" scope="normal" type="function" from="gridx/support/exporter/toCSV"><parameters/><return-types/></method><method name="handleCell" scope="normal" type="function" from="gridx/support/exporter/toCSV"><parameters><parameter name="context" type="Object" usage="required"><description>&lt;p>An object with the following properties:
&lt;/p>
</description></parameter></parameters><return-types/></method><method name="afterRow" scope="normal" type="function" from="gridx/support/exporter/toCSV"><parameters/><return-types/></method><method name="getResult" scope="normal" type="function" from="gridx/support/exporter/toCSV"><parameters/><return-types><return-type type="undefined"/></return-types></method></methods></object><object location="gridx/modules/exporter/Table" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides the API to export grid contents to an HTML table, which is mainly used in print.&lt;/p>
</summary></object><object location="gridx/modules/extendedSelect/Cell" type="constructor" classlike="true" superclass="gridx/modules/extendedSelect/_RowCellBase"><properties><property name="enabled" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingCtrl" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingShift" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="selectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/Cell"><parameters><parameter name="rowId" type="undefined" usage="required"/><parameter name="columnId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Select a cell by (rowId, columnId)&lt;/p>
</summary></method><method name="deselectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/Cell"><parameters><parameter name="columnId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselect a cell by (rowId, columnId)&lt;/p>
</summary></method><method name="selectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/Cell"><parameters><parameter name="rowIndex" type="undefined" usage="required"/><parameter name="columnIndex" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Select a cess by (rowIndex, columnIndex)&lt;/p>
</summary></method><method name="deSelectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/Cell"><parameters><parameter name="rowIndex" type="undefined" usage="required"/><parameter name="columnIndex" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselect a cell by (rowIndex, columnIndex)&lt;/p>
</summary></method><method name="getSelected" scope="prototype" type="function" from="gridx/modules/extendedSelect/Cell"><parameters/><return-types/><summary>&lt;p>Get an array of selected cells e.g.[[&amp;#39;row1&amp;#39;, &amp;#39;col1&amp;#39;], [&amp;#39;row2&amp;#39;, &amp;#39;col2&amp;#39;]]&lt;/p>
</summary></method><method name="clear" scope="prototype" type="function" from="gridx/modules/extendedSelect/Cell"><parameters><parameter name="silent" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselected all selected cells&lt;/p>
</summary></method><method name="isSelected" scope="prototype" type="function" from="gridx/modules/extendedSelect/Cell"><parameters><parameter name="rowId" type="undefined" usage="required"/><parameter name="columnId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Check if the given cell is selected.&lt;/p>
</summary></method><method name="deselectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="start" type="undefined" usage="required"/><parameter name="end" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="onSelectionChange" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="newSelectedIds" type="undefined" usage="required"/><parameter name="oldSelectedIds" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Event: fired when the selection is changed.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/extendedSelect/_RowCellBase"/></mixins><summary>&lt;p>Provides advanced cell selections.&lt;/p>
</summary><description>&lt;p>This module provides an advanced way for selecting cells by clicking, swiping, SPACE key, or CTRL/SHIFT CLICK to select multiple cell.
&lt;/p>
</description><examples><example>&lt;ol>
&lt;li>&lt;p>Use select api on cell object obtained from grid.cell(i,j)&lt;/p>
&lt;p> grid.cell(1,1).select();
 grid.cell(1,1).deselect();
 grid.cell(1,1).isSelected();&lt;/p>
&lt;/li>
&lt;li>&lt;p>Use select api on select.cell module&lt;/p>
&lt;p> grid.select.cell.selectById(columnId);
 grid.select.cell.deSelectById(columnId);
 grid.select.cell.isSelected(columnId);
 grid.select.cell.getSelected();//[]
 grid.select.cell.clear();&lt;/p>
&lt;/li>
&lt;/ol>
</example></examples></object><object location="gridx/modules/extendedSelect/Column" type="constructor" classlike="true" superclass="gridx/modules/extendedSelect/_Base"><properties><property name="enabled" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingCtrl" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="holdingShift" scope="prototype" type="boolean" from="gridx/modules/extendedSelect/_Base"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="selectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/Column"><parameters><parameter name="columnId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Select a column by id.&lt;/p>
</summary></method><method name="deselectById" scope="prototype" type="function" from="gridx/modules/extendedSelect/Column"><parameters><parameter name="columnId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselect a column by id.&lt;/p>
</summary></method><method name="selectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/Column"><parameters><parameter name="columnIndex" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Select a column by index&lt;/p>
</summary></method><method name="deSelectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/Column"><parameters><parameter name="columnIndex" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselect a column by index.&lt;/p>
</summary></method><method name="getSelected" scope="prototype" type="function" from="gridx/modules/extendedSelect/Column"><parameters/><return-types/><summary>&lt;p>Get id array of all selected columns&lt;/p>
</summary></method><method name="clear" scope="prototype" type="function" from="gridx/modules/extendedSelect/Column"><parameters><parameter name="silent" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselected all selected columns;&lt;/p>
</summary></method><method name="isSelected" scope="prototype" type="function" from="gridx/modules/extendedSelect/Column"><parameters/><return-types/><summary>&lt;p>Check if the given column(s) are all selected.&lt;/p>
</summary></method><method name="deselectByIndex" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="start" type="undefined" usage="required"/><parameter name="end" type="undefined" usage="required"/></parameters><return-types><return-type type="undefined"/></return-types></method><method name="onSelectionChange" scope="prototype" type="function" from="gridx/modules/extendedSelect/_Base"><parameters><parameter name="newSelectedIds" type="undefined" usage="required"/><parameter name="oldSelectedIds" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Event: fired when the selection is changed.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/extendedSelect/_Base"/></mixins><summary>&lt;p>Provides advanced column selections.&lt;/p>
</summary><description>&lt;p>This module provides an advanced way for selecting columns by clicking, swiping, SPACE key, or CTRL/SHIFT CLICK to select multiple columns.
&lt;/p>
</description><examples><example>&lt;ol>
&lt;li>&lt;p>Use select api on column object obtained from grid.column(i)&lt;/p>
&lt;p> grid.column(1).select();
 grid.column(1).deselect();
 grid.column(1).isSelected();&lt;/p>
&lt;/li>
&lt;li>&lt;p>Use select api on select.row module&lt;/p>
&lt;p> grid.select.column.selectById(columnId);
 grid.select.column.deSelectById(columnId);
 grid.select.column.isSelected(columnId);
 grid.select.column.getSelected();//[]
 grid.select.column.clear();&lt;/p>
&lt;/li>
&lt;/ol>
</example></examples></object><object location="gridx/modules/filter/DistinctComboBoxMenu" type="constructor" classlike="true"><properties/><methods/></object><object location="gridx/modules/filter/Filter" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="string" from="gridx/modules/Filter"/><property name="serverMode" scope="prototype" type="boolean" from="gridx/modules/Filter"/><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property><property name="before" scope="normal" type="undefined" from="gridx/modules/filter/FilterBar" extension-module="true"/><property name="after" scope="normal" type="undefined" from="gridx/modules/filter/FilterBar" extension-module="true"/></properties><methods><method name="setupFilterQuery" scope="prototype" type="function" from="gridx/modules/Filter"><parameters><parameter name="obj" type="undefined" usage="required"/></parameters><return-types/></method><method name="setFilter" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types/><summary>&lt;p>Apply function &lt;em>checker&lt;/em> as the filter condition to filter every row.&lt;/p>
</summary></method><method name="getFilter" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types><return-type type="undefined"/></return-types><summary>&lt;p>Return the current checker function.&lt;/p>
</summary></method><method name="refresh" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types/><summary>&lt;p>Re-filter the grid with current filter. Useful when data is changed.&lt;/p>
</summary></method><method name="column" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types/></method><method name="value" scope="prototype" type="function" from="gridx/modules/Filter"><parameters/><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module makes it possible for user to set arbitrary filter condition to grid.&lt;/p>
</summary></object><object location="gridx/modules/filter/FilterBar" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="filterData" scope="prototype" type="Object" from="gridx/modules/filter/FilterBar"><summary>&lt;p>Set the initial filter rules. Format is:
{
    type: &amp;quot;all&amp;quot;,
    conditions: [
        {}
    ]
}&lt;/p>
</summary></property><property name="closeButton" scope="prototype" type="Boolean" from="gridx/modules/filter/FilterBar"><summary>&lt;p>TRUE to show a small button on the filter bar for the user to close/hide the filter bar.&lt;/p>
</summary></property><property name="defineFilterButton" scope="prototype" type="Boolean" from="gridx/modules/filter/FilterBar"><summary>&lt;p>FALSE to hide the define filter button on the left side (right side for RTL) of the filter bar.&lt;/p>
</summary></property><property name="tooltipDelay" scope="prototype" type="Number" from="gridx/modules/filter/FilterBar"><summary>&lt;p>Time in mili-seconds of the delay to show the Filter Status Tooltip when mouse is hovering on the filter bar.&lt;/p>
</summary></property><property name="maxRuleCount" scope="prototype" type="Integer" from="gridx/modules/filter/FilterBar"><summary>&lt;p>Maximum rule count that can be applied in the Filter Definition Dialog.
If &amp;lt;= 0 or not number, then infinite rules are supported.&lt;/p>
</summary></property><property name="ruleCountToConfirmClearFilter" scope="prototype" type="number" from="gridx/modules/filter/FilterBar"><summary>&lt;p>If the filter rule count is larger than or equal to this value, then a confirm dialog will show when clearing filter.
If set to less than 1 or null, then always show the confirm dialog.
If set to Infinity, then never show the confirm dialog.
Default value is 2.&lt;/p>
</summary></property><property name="itemsName" scope="prototype" type="String" from="gridx/modules/filter/FilterBar"><summary>&lt;p>The general name of the items listed in the grid.
If not provided, then search the language bundle.&lt;/p>
</summary></property><property name="conditions" scope="prototype" type="object" from="gridx/modules/filter/FilterBar"/><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="applyFilter" scope="prototype" type="function" from="gridx/modules/filter/FilterBar"><parameters><parameter name="filterData" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Apply the filter data.&lt;/p>
</summary></method><method name="refresh" scope="prototype" type="function" from="gridx/modules/filter/FilterBar"><parameters/><return-types/><summary>&lt;p>Re-draw the filter bar if necessary with the current attributes.&lt;/p>
</summary><examples><example>&lt;p>grid.filterBar.closeButton = true;
grid.filterBar.refresh();&lt;/p>
</example></examples></method><method name="isVisible" scope="prototype" type="function" from="gridx/modules/filter/FilterBar"><parameters/><return-types/></method><method name="show" scope="prototype" type="function" from="gridx/modules/filter/FilterBar"><parameters/><return-types/><summary>&lt;p>Show the filter bar. (May add animation later)&lt;/p>
</summary></method><method name="hide" scope="prototype" type="function" from="gridx/modules/filter/FilterBar"><parameters/><return-types/><summary>&lt;p>Hide the filter bar. (May add animation later)&lt;/p>
</summary></method><method name="onShow" scope="prototype" type="function" from="gridx/modules/filter/FilterBar"><parameters/><return-types/></method><method name="onHide" scope="prototype" type="function" from="gridx/modules/filter/FilterBar"><parameters/><return-types/></method><method name="showFilterDialog" scope="prototype" type="function" from="gridx/modules/filter/FilterBar"><parameters/><return-types/><summary>&lt;p>Show the filter define dialog.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>Filter bar module.&lt;/p>
</summary></object><object location="gridx/modules/filter/FilterDialog" type="constructor" classlike="true"><properties/><methods/></object><object location="gridx/modules/filter/FilterPane" type="constructor" classlike="true"><properties/><methods/></object><object location="gridx/modules/filter/FilterConfirmDialog" type="constructor" classlike="true"><properties/><methods/></object><object location="gridx/modules/filter/FilterTooltip" type="constructor" classlike="true"><properties/><methods/><summary>&lt;p>Show status dialog of filter.&lt;/p>
</summary></object><object location="gridx/modules/filter/QuickFilter" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins></object><object location="gridx/support/QuickFilter" type="constructor" classlike="true"><properties><property name="grid" scope="prototype" type="gridx/Grid" from="gridx/support/QuickFilter"><summary>&lt;p>The grid widget this plugin works for.&lt;/p>
</summary></property><property name="textBoxClass" scope="prototype" type="string" from="gridx/support/QuickFilter"/><property name="buttonClass" scope="prototype" type="string" from="gridx/support/QuickFilter"/><property name="comboButtonClass" scope="prototype" type="string" from="gridx/support/QuickFilter"/><property name="menuClass" scope="prototype" type="string" from="gridx/support/QuickFilter"/><property name="menuItemClass" scope="prototype" type="string" from="gridx/support/QuickFilter"/><property name="autoApply" scope="prototype" type="boolean" from="gridx/support/QuickFilter"/><property name="delay" scope="prototype" type="Integer" from="gridx/support/QuickFilter"><summary>&lt;p>The time (in ms) delay before applying the filter after each key stroke in the filter box.
Only effective when autoApply is true, &lt;/p>
</summary></property></properties><methods/><summary>&lt;p>Quick filter box.&lt;/p>
</summary></object><object location="gridx/modules/pagination/Pagination" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="pageSize" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The current page size&lt;/p>
</return-description><summary>&lt;p>Get current page size&lt;/p>
</summary></method><method name="isAll" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>Whether the grid is showing all rows.&lt;/p>
</return-description><summary>&lt;p>Check if the grid is currently showing all rows (page size set to 0).&lt;/p>
</summary></method><method name="pageCount" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The current count of pages.&lt;/p>
</return-description><summary>&lt;p>Get the current count of pages.&lt;/p>
</summary></method><method name="currentPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters/><return-types><return-type type="any"/></return-types><return-description>&lt;p>The index of current page.&lt;/p>
</return-description><summary>&lt;p>Get the index of current page.&lt;/p>
</summary></method><method name="firstIndexInPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="page" type="Integer" usage="required"><summary>&lt;p>The index of a page.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The index of the first row in the page. If page is not valid, return -1.&lt;/p>
</return-description><summary>&lt;p>Get the index of the first row in the given page.&lt;/p>
</summary></method><method name="lastIndexInPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="page" type="Integer" usage="required"><summary>&lt;p>The index of a page&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The index of the last row in the given page.&lt;/p>
</return-description><summary>&lt;p>Get the index of the last row in the given page.&lt;/p>
</summary></method><method name="pageOfIndex" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="index" type="Integer" usage="required"><summary>&lt;p>The row index&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The page index&lt;/p>
</return-description><summary>&lt;p>Get the index of the page that the given row is in.&lt;/p>
</summary></method><method name="indexInPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="index" type="Integer" usage="required"><summary>&lt;p>The row index&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The row index in page&lt;/p>
</return-description><summary>&lt;p>Get the row index in page by overall row index&lt;/p>
</summary></method><method name="filterIndexesInPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="indexes" type="Integer[]" usage="required"><summary>&lt;p>An array of row indexes.&lt;/p>
</summary></parameter><parameter name="page" type="Integer" usage="required"><summary>&lt;p>A page index&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>A subset of indexes that appear in the given page.&lt;/p>
</return-description><summary>&lt;p>Filter out the indexes that are in the given page.&lt;/p>
</summary></method><method name="gotoPage" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="page" type="Integer" usage="required"><summary>&lt;p>A page index&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Set the current page&lt;/p>
</summary></method><method name="setPageSize" scope="prototype" type="function" from="gridx/modules/Pagination"><parameters><parameter name="size" type="Integer" usage="required"><summary>&lt;p>The new page size &lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Set page size (count of rows in one page)&lt;/p>
</summary></method><method name="onSwitchPage" scope="prototype" type="function" from="gridx/modules/Pagination" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when switched to another page.&lt;/p>
</summary></method><method name="onChangePageSize" scope="prototype" type="function" from="gridx/modules/Pagination" tags="callback"><parameters/><return-types/><summary>&lt;p>Fired when the page size is changed&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins><summary>&lt;p>This module provides (logical) pagination functionality for grid.&lt;/p>
</summary><description>&lt;p>This module does not include any UI buttons for pagination, so that various
kinds of pagination UI implementations can benifit from this module.&lt;/p>
</description></object><object location="gridx/modules/pagination/PaginationBar" type="constructor" classlike="true" superclass="gridx/modules/pagination/_PaginationBarBase"><properties><property name="visibleSteppers" scope="prototype" type="number" from="gridx/modules/pagination/PaginationBar"/><property name="sizeSeparator" scope="prototype" type="string" from="gridx/modules/pagination/PaginationBar"/><property name="gotoButton" scope="prototype" type="boolean" from="gridx/modules/pagination/PaginationBar"/><property name="sizes" scope="prototype" type="Array" from="gridx/modules/pagination/_PaginationBarBase"/><property name="position" scope="prototype" type="String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>The position of the pagination bar, can be &amp;quot;bottom&amp;quot; (default), &amp;quot;top&amp;quot; or &amp;quot;both&amp;quot; (any other value means &amp;quot;both&amp;quot;)&lt;/p>
</summary></property><property name="description" scope="prototype" type="Boolean|String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>Whether (and where) to show &amp;quot;description&amp;quot; part of the pagination bar UI.
Can be true/false, or &amp;quot;bottom&amp;quot;, or &amp;quot;top&amp;quot;&lt;/p>
</summary></property><property name="stepper" scope="prototype" type="Boolean|String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>Whether (and where) to show &amp;quot;page stepper&amp;quot; part of the pagination bar UI.
Can be true/false, or &amp;quot;bottom&amp;quot;, or &amp;quot;top&amp;quot;&lt;/p>
</summary></property><property name="sizeSwitch" scope="prototype" type="Boolean|String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>Whether (and where) to show &amp;quot;size switch&amp;quot; part of the pagination bar UI.
Can be true/false, or &amp;quot;bottom&amp;quot;, or &amp;quot;top&amp;quot;&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/modules/pagination/_PaginationBarBase"><parameters/><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/pagination/_PaginationBarBase"/></mixins></object><object location="gridx/modules/pagination/_PaginationBarBase" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="sizes" scope="prototype" type="Array" from="gridx/modules/pagination/_PaginationBarBase"/><property name="position" scope="prototype" type="String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>The position of the pagination bar, can be &amp;quot;bottom&amp;quot; (default), &amp;quot;top&amp;quot; or &amp;quot;both&amp;quot; (any other value means &amp;quot;both&amp;quot;)&lt;/p>
</summary></property><property name="description" scope="prototype" type="Boolean|String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>Whether (and where) to show &amp;quot;description&amp;quot; part of the pagination bar UI.
Can be true/false, or &amp;quot;bottom&amp;quot;, or &amp;quot;top&amp;quot;&lt;/p>
</summary></property><property name="stepper" scope="prototype" type="Boolean|String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>Whether (and where) to show &amp;quot;page stepper&amp;quot; part of the pagination bar UI.
Can be true/false, or &amp;quot;bottom&amp;quot;, or &amp;quot;top&amp;quot;&lt;/p>
</summary></property><property name="sizeSwitch" scope="prototype" type="Boolean|String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>Whether (and where) to show &amp;quot;size switch&amp;quot; part of the pagination bar UI.
Can be true/false, or &amp;quot;bottom&amp;quot;, or &amp;quot;top&amp;quot;&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/modules/pagination/_PaginationBarBase"><parameters/><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins></object><object location="gridx/modules/pagination/PaginationBarDD" type="constructor" classlike="true" superclass="gridx/modules/pagination/_PaginationBarBase"><properties><property name="sizes" scope="prototype" type="Array" from="gridx/modules/pagination/_PaginationBarBase"/><property name="position" scope="prototype" type="String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>The position of the pagination bar, can be &amp;quot;bottom&amp;quot; (default), &amp;quot;top&amp;quot; or &amp;quot;both&amp;quot; (any other value means &amp;quot;both&amp;quot;)&lt;/p>
</summary></property><property name="description" scope="prototype" type="Boolean|String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>Whether (and where) to show &amp;quot;description&amp;quot; part of the pagination bar UI.
Can be true/false, or &amp;quot;bottom&amp;quot;, or &amp;quot;top&amp;quot;&lt;/p>
</summary></property><property name="stepper" scope="prototype" type="Boolean|String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>Whether (and where) to show &amp;quot;page stepper&amp;quot; part of the pagination bar UI.
Can be true/false, or &amp;quot;bottom&amp;quot;, or &amp;quot;top&amp;quot;&lt;/p>
</summary></property><property name="sizeSwitch" scope="prototype" type="Boolean|String" from="gridx/modules/pagination/_PaginationBarBase"><summary>&lt;p>Whether (and where) to show &amp;quot;size switch&amp;quot; part of the pagination bar UI.
Can be true/false, or &amp;quot;bottom&amp;quot;, or &amp;quot;top&amp;quot;&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="refresh" scope="prototype" type="function" from="gridx/modules/pagination/_PaginationBarBase"><parameters/><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/pagination/_PaginationBarBase"/></mixins></object><object location="gridx/modules/select/Cell" type="constructor" classlike="true" superclass="gridx/modules/select/_RowCellBase"><properties><property name="enabled" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether this module is enabled.&lt;/p>
</summary></property><property name="multiple" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether multiple selectionis allowe.&lt;/p>
</summary></property><property name="holdingCtrl" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether to add to selection all the time (as if the CTRL key is always held).&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="selectById" scope="prototype" type="function" from="gridx/modules/select/Cell"><parameters><parameter name="rowId" type="undefined" usage="required"/><parameter name="columnId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Select a cell by [rowId, columnId].&lt;/p>
</summary></method><method name="deselectById" scope="prototype" type="function" from="gridx/modules/select/Cell"><parameters><parameter name="rowId" type="undefined" usage="required"/><parameter name="columnId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselect a cell by [rowId, columnId].&lt;/p>
</summary></method><method name="isSelected" scope="prototype" type="function" from="gridx/modules/select/Cell"><parameters><parameter name="rowId" type="undefined" usage="required"/><parameter name="columnId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Check if a cell is already selected.&lt;/p>
</summary></method><method name="getSelected" scope="prototype" type="function" from="gridx/modules/select/Cell"><parameters/><return-types/><summary>&lt;p>Get arrays of [rowId, columnId] of all the selected cells&lt;/p>
</summary></method><method name="clear" scope="prototype" type="function" from="gridx/modules/select/Cell"><parameters><parameter name="notClearCell" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselected all the selected cells;&lt;/p>
</summary></method><method name="onSelected" scope="prototype" type="function" from="gridx/modules/select/Cell"><parameters><parameter name="cell" type="gridx.core.Cell" usage="required"><summary>&lt;p>The cell object (null if the row of the cell is not yet loaded)&lt;/p>
</summary></parameter><parameter name="rowId" type="string|number" usage="required"><summary>&lt;p>The row id&lt;/p>
</summary></parameter><parameter name="colId" type="string|number" usage="required"><summary>&lt;p>The column id&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when a cell is selected.&lt;/p>
</summary></method><method name="onDeselected" scope="prototype" type="function" from="gridx/modules/select/Cell"><parameters><parameter name="cell" type="gridx.core.Cell" usage="required"><summary>&lt;p>The cell object&lt;/p>
</summary></parameter><parameter name="rowId" type="string|number" usage="required"><summary>&lt;p>The row id&lt;/p>
</summary></parameter><parameter name="colId" type="string|number" usage="required"><summary>&lt;p>The column id&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when a cell is deselected.&lt;/p>
</summary></method><method name="onHighlightChange" scope="prototype" type="function" from="gridx/modules/select/Cell" private="true" tags="private package"><parameters/><return-types/><summary>&lt;p>Fired when a cell&amp;#39;s highlight is changed.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/select/_RowCellBase"/></mixins><summary>&lt;p>Provides simple cell selection.&lt;/p>
</summary><description>&lt;p>This module provides a simple way for selecting cells by clicking or SPACE key, or CTRL + Click to select multiple cells.
&lt;/p>
</description><examples><example>&lt;ol>
&lt;li>&lt;p>Use select api on grid cell object obtained from grid.cell(i, j)&lt;/p>
&lt;p> grid.cell(1,1).select();
 grid.cell(1,1).deselect();
 grid.cell(1,1).isSelected();&lt;/p>
&lt;/li>
&lt;li>&lt;p>Use select api on select.cell module&lt;/p>
&lt;p> grid.select.cell.selectById(rowId, columnId);
 grid.select.cell.deSelectById(rowId, columnId);
 grid.select.cell.isSelected(rowId, columnId);&lt;br> grid.select.cell.getSelected();//[]
 grid.select.cell.clear();&lt;/p>
&lt;/li>
&lt;/ol>
</example></examples></object><object location="gridx/modules/select/_RowCellBase" type="constructor" classlike="true" superclass="gridx/modules/select/_Base"><properties><property name="enabled" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether this module is enabled.&lt;/p>
</summary></property><property name="multiple" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether multiple selectionis allowe.&lt;/p>
</summary></property><property name="holdingCtrl" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether to add to selection all the time (as if the CTRL key is always held).&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="onSelected" scope="prototype" type="function" from="gridx/modules/select/_Base"><parameters/><return-types/></method><method name="onDeselected" scope="prototype" type="function" from="gridx/modules/select/_Base"><parameters/><return-types/></method><method name="onHighlightChange" scope="prototype" type="function" from="gridx/modules/select/_Base"><parameters/><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/select/_Base"/></mixins></object><object location="gridx/modules/select/_Base" type="constructor" classlike="true" superclass="gridx/core/_Module"><properties><property name="enabled" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether this module is enabled.&lt;/p>
</summary></property><property name="multiple" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether multiple selectionis allowe.&lt;/p>
</summary></property><property name="holdingCtrl" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether to add to selection all the time (as if the CTRL key is always held).&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="onSelected" scope="prototype" type="function" from="gridx/modules/select/_Base"><parameters/><return-types/></method><method name="onDeselected" scope="prototype" type="function" from="gridx/modules/select/_Base"><parameters/><return-types/></method><method name="onHighlightChange" scope="prototype" type="function" from="gridx/modules/select/_Base"><parameters/><return-types/></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/core/_Module"/></mixins></object><object location="gridx/modules/select/Column" type="constructor" classlike="true" superclass="gridx/modules/select/_Base"><properties><property name="enabled" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether this module is enabled.&lt;/p>
</summary></property><property name="multiple" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether multiple selectionis allowe.&lt;/p>
</summary></property><property name="holdingCtrl" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether to add to selection all the time (as if the CTRL key is always held).&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="selectById" scope="prototype" type="function" from="gridx/modules/select/Column"><parameters><parameter name="id" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Select target column by id&lt;/p>
</summary></method><method name="deselectById" scope="prototype" type="function" from="gridx/modules/select/Column"><parameters><parameter name="id" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselect target column by id&lt;/p>
</summary></method><method name="isSelected" scope="prototype" type="function" from="gridx/modules/select/Column"><parameters><parameter name="id" type="undefined" usage="required"/></parameters><return-types><return-type type="boolean"/></return-types><summary>&lt;p>Check if a column is selected &lt;/p>
</summary></method><method name="getSelected" scope="prototype" type="function" from="gridx/modules/select/Column"><parameters/><return-types><return-type type="Array"/></return-types><summary>&lt;p>Get array of column id of all selected columns&lt;/p>
</summary></method><method name="clear" scope="prototype" type="function" from="gridx/modules/select/Column"><parameters><parameter name="notClearId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Clear all column selections&lt;/p>
</summary></method><method name="onSelected" scope="prototype" type="function" from="gridx/modules/select/Column"><parameters><parameter name="col" type="gridx.core.Column" usage="required"><summary>&lt;p>The column object&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when a column is selected.&lt;/p>
</summary></method><method name="onDeselected" scope="prototype" type="function" from="gridx/modules/select/Column"><parameters><parameter name="col" type="gridx.core.Column" usage="required"><summary>&lt;p>The column object&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when a column is deselected.&lt;/p>
</summary></method><method name="onHighlightChange" scope="prototype" type="function" from="gridx/modules/select/Column" private="true" tags="private package"><parameters/><return-types/><summary>&lt;p>Fired when a column&amp;#39;s highlight is changed.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/select/_Base"/></mixins><summary>&lt;p>Provides simple column selection.&lt;/p>
</summary><description>&lt;p>This module provides a simple way for selecting columns by clicking or SPACE key, 
or CTRL + Click to select multiple columns.
&lt;/p>
</description><examples><example>&lt;ol>
&lt;li>&lt;p>Use select api on grid column object obtained from grid.column(i)&lt;/p>
&lt;p> grid.column(1).select();
 grid.column(1).deselect();
 grid.column(1).isSelected();&lt;/p>
&lt;/li>
&lt;li>&lt;p>Use select api on select.column module&lt;/p>
&lt;p> grid.select.column.selectById(columnId);
 grid.select.column.deSelectById(columnId);
 grid.select.column.isSelected(columnId);
 grid.select.column.getSelected();//[]
 grid.select.column.clear();&lt;/p>
&lt;/li>
&lt;/ol>
</example></examples></object><object location="gridx/modules/select/Row" type="constructor" classlike="true" superclass="gridx/modules/select/_RowCellBase"><properties><property name="triggerOnCell" scope="prototype" type="Boolean" from="gridx/modules/select/Row" tags="readonly"><summary>&lt;p>Whether row will be selected by clicking on cell, false by default&lt;/p>
</summary></property><property name="treeMode" scope="prototype" type="Boolean" from="gridx/modules/select/Row"><summary>&lt;p>Whether to apply tri-state selection for child rows.&lt;/p>
</summary></property><property name="enabled" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether this module is enabled.&lt;/p>
</summary></property><property name="multiple" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether multiple selectionis allowe.&lt;/p>
</summary></property><property name="holdingCtrl" scope="prototype" type="Boolean" from="gridx/modules/select/_Base"><summary>&lt;p>Whether to add to selection all the time (as if the CTRL key is always held).&lt;/p>
</summary></property><property name="name" scope="prototype" type="String" from="gridx/core/_Module"><summary>&lt;p>The API set name of this module. This name represents the API set that this module implements, 
instead of this module itself. Two different modules can have the same name, so that they provide
two different implementations of this API set.
For example, simple row selection and extended row selection are two modules implementing a same set of APIs.
They can be used in two different grids in one page (maybe due to different requirements), 
without worrying about conflicting with eachother. And any module of grid can be replaced by a new implementation
without re-writing any other modules.
This property is mandatary.&lt;/p>
</summary></property><property name="forced" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. All these modules must exist, and have finished loading before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="optional" scope="prototype" type="String[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules can be absent, but if they do exist, 
they must be loaded before this module loads.
This property can be omitted.&lt;/p>
</summary></property><property name="required" scope="prototype" type="[]" from="gridx/core/_Module"><summary>&lt;p>An array of module names. These modules must exist, but they can be loaded at any time.
This property can be omitted.&lt;/p>
</summary></property><property name="grid" scope="prototype" type="gridx.Grid" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid&lt;/p>
</summary></property><property name="model" scope="prototype" type="gridx.core.model.Model" from="gridx/core/_Module"><summary>&lt;p>Reference to the grid model&lt;/p>
</summary></property><property name="loaded" scope="prototype" type="dojo.Deferred" from="gridx/core/_Module"><summary>&lt;p>Indicate when this module is completely loaded.&lt;/p>
</summary></property></properties><methods><method name="selectById" scope="prototype" type="function" from="gridx/modules/select/Row"><parameters><parameter name="rowId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Select a row by id.&lt;/p>
</summary></method><method name="deselectById" scope="prototype" type="function" from="gridx/modules/select/Row"><parameters><parameter name="rowId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselect a row by id.&lt;/p>
</summary></method><method name="isSelected" scope="prototype" type="function" from="gridx/modules/select/Row"><parameters><parameter name="rowId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Check if a row is already selected.&lt;/p>
</summary></method><method name="getSelected" scope="prototype" type="function" from="gridx/modules/select/Row"><parameters/><return-types/><summary>&lt;p>Get id array of all selected rows&lt;/p>
</summary></method><method name="clear" scope="prototype" type="function" from="gridx/modules/select/Row"><parameters><parameter name="notClearId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Deselected all selected rows;&lt;/p>
</summary></method><method name="onSelected" scope="prototype" type="function" from="gridx/modules/select/Row"><parameters><parameter name="row" type="grid.core.Row" usage="required"><summary>&lt;p>The Row object (null if the row is not yet loaded);&lt;/p>
</summary></parameter><parameter name="rowId" type="undefined" usage="required"><summary>&lt;p>The row ID&lt;/p>
</summary></parameter></parameters><return-types/><summary>&lt;p>Fired when a row is selected.&lt;/p>
</summary></method><method name="onDeselected" scope="prototype" type="function" from="gridx/modules/select/Row"><parameters><parameter name="row" type="grid.core.Row" usage="required"><summary>&lt;p>The Row object (null if the row is not yet loaded);&lt;/p>
</summary></parameter><parameter name="rowId" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Fired when a row is deselected.&lt;/p>
</summary></method><method name="onHighlightChange" scope="prototype" type="function" from="gridx/modules/select/Row" private="true" tags="private package"><parameters/><return-types/><summary>&lt;p>Fired when a row&amp;#39;s highlight is changed.&lt;/p>
</summary></method><method name="getAPIPath" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>This function defines how to access this module&amp;#39;s methods from the grid object.&lt;/p>
</summary><description>&lt;p>The returned object of this function will be &amp;quot;recursively&amp;quot; mixed into the grid object.
That is, any property of object type in grid will be preserved. For example, if this function
returns { abc: { def: &amp;#39;ghi&amp;#39;} }, and the grid already has a property called &amp;quot;abc&amp;quot;, and 
grid.abc is { jkl: &amp;#39;mno&amp;#39;}. Then after mixin, grid.abc will still have this jkl property:

&lt;/p>
&lt;pre>&lt;code>{
    abc: {
        jkl: &amp;#39;mno&amp;#39;,
        def: &amp;#39;ghi&amp;#39;
    }
}&lt;/code>&lt;/pre>
&lt;p>This mechanism makes it possible for different modules to provide APIs to a same sub-API object.

&lt;/p>
&lt;p>Sub-API object is used to provide structures for grid APIs, so as to avoid API conflicts as much as possible.
This function can be omitted.&lt;/p>
</description></method><method name="preload" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Preload this module.&lt;/p>
</summary><description>&lt;p>If this function exists, it is called after all modules are created (&amp;quot;new&amp;quot;-ed), but not yet loaded.
At this time point, all the module APIs are already accessable, so all the mothods of those modules that
do not need to load can be used here.
Note that this function is not the &amp;quot;load&amp;quot; process, so the module dependancy is not honored. For example,
if module A forcedly depends on module B, it is still possible that module A.preload is called before 
module B.preload.
This function can be omitted.&lt;/p>
</description></method><method name="load" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="args" type="undefined" usage="required"/><parameter name="deferStartup" type="undefined" usage="required"/></parameters><return-types/><summary>&lt;p>Completely load this module.&lt;/p>
</summary><description>&lt;p>This is the formal loading process of this module. This function will not be called until all the &amp;quot;forced&amp;quot;
and existing &amp;quot;optional&amp;quot; modules are loaded. When the loading process of this module is finished (Note that
this might be an async process), this.loaded.callback() must be called to tell any other modules that
depend on this module.&lt;/p>
</description></method><method name="arg" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="argName" type="String" usage="required"><summary>&lt;p>The name of this argument. This is the &amp;quot;short&amp;quot; name, not the name prefixed with module name.&lt;/p>
</summary></parameter><parameter name="defaultValue" type="anything" usage="optional"><summary>&lt;p>This value will by asigned to the argument if there&amp;#39;s no user provided values.&lt;/p>
</summary></parameter><parameter name="validate" type="Function" usage="optional"><summary>&lt;p>This is a validation function and it must return a boolean value. If the user provided value
can not pass validation, the default value will be used.
Note if this function is provided, defaultValue must also be provided.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The value of this argument.&lt;/p>
</return-description><summary>&lt;p>This method provides a normalized way to access module arguments.&lt;/p>
</summary><description>&lt;p>There are two ways to provide module arguments when creating grid.
One is to write them in the module declaration object:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        {
            moduleClass: gridx.modules.Pagination,
            initialPage: 1      //Put module arguments in module declaration object
        }
    ],
    ......
});&lt;/code>&lt;/pre>
&lt;p>This way is straightforward, but quite verbose. And if user would like to set arguments 

&lt;/p>
&lt;p>for pre-included core modules (e.g. Header, Body), he&amp;#39;d have to explictly declare the
module. This would be too demanding for a grid user, so we need another approach.
The other way is to treat them as grid arguments:

&lt;/p>
&lt;pre>&lt;code>var grid = new Grid({
    ......
    modules: [
        gridx.modules.Pagination
    ],
    paginationInitialPage: 1,   //Treat module arguments as grid arguments
    ......
});&lt;/code>&lt;/pre>
&lt;p>In this way, there&amp;#39;s no need to provide a module declaration object, but one has to tell

&lt;/p>
&lt;p>grid for which module the arguments is applied. One can simply put the module name at the
front of every module argument:
    &amp;quot;pagination&amp;quot; -- module name
&lt;/p>
&lt;pre>&lt;code>&amp;quot;initialPage&amp;quot; -- module argument
---------------------------------
paginationInitialPage -- module argument treated as grid argument&lt;/code>&lt;/pre>
&lt;p>Note the first letter of the module arugment must be capitalized in the combined argument.

&lt;/p>
&lt;p>This &amp;quot;arg&amp;quot; method makes it possible to access module arguments without worring about where
they are declared. The priority of every kinds of declarations are:
    Module argument &amp;gt; Grid argument &amp;gt; default value &amp;gt; Base class argument (inherited)
After this method, the argument will automatically become module argument. But it is still
recommended to alway access arguments by this.arg(...);&lt;/p>
</description></method><method name="connect" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="obj" type="Object" usage="required"/><parameter name="e" type="String" usage="required"/><parameter name="method" type="String|Function" usage="required"/><parameter name="scope" type="Object" usage="optional"/><parameter name="flag" type="Anything" usage="required"><summary>&lt;p>If provided, the listener will only be triggered when grid._eventFlags[e] is set to flag.&lt;/p>
</summary></parameter></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The connect handle&lt;/p>
</return-description><summary>&lt;p>Connect an event handler to an event or function.&lt;/p>
</summary><description>&lt;p>Similar to widget.connect, the scope of the listener will be default to this module.
But in this API, the scope argument is placed behind the listener function, so as to
avoid arguemnt checking logic.
This method also allows conditional event firing using the flag argument.&lt;/p>
</description></method><method name="batchConnect" scope="prototype" type="function" from="gridx/core/_Module"><parameters/><return-types/><summary>&lt;p>Do a lot of connects in a batch.&lt;/p>
</summary><description>&lt;p>This method is used to optimize code size.&lt;/p>
</description></method><method name="subscribe" scope="prototype" type="function" from="gridx/core/_Module"><parameters><parameter name="topic" type="undefined" usage="required"/><parameter name="method" type="undefined" usage="required"/><parameter name="scope" type="undefined" usage="required"/></parameters><return-types><return-type type="any"/></return-types><return-description>&lt;p>The subscription handle&lt;/p>
</return-description><summary>&lt;p>Subscribe to a topic.&lt;/p>
</summary><description>&lt;p>This is similar to widget.subscribe, except that the &amp;quot;scope&amp;quot; argument in this method is behind the listener function.&lt;/p>
</description></method></methods><mixins><mixin location="gridx/modules/select/_RowCellBase"/></mixins><summary>&lt;p>Provides simple row selection.&lt;/p>
</summary><description>&lt;p>This module provides a simple way for selecting rows by clicking or SPACE key, or CTRL + Click to select multiple rows.
&lt;/p>
</description><examples><example>&lt;ol>
&lt;li>&lt;p>Use select api on grid row object obtained from grid.row(i)&lt;/p>
&lt;p> grid.row(1).select();
 grid.row(1).deselect();
 grid.row(1).isSelected();&lt;/p>
&lt;/li>
&lt;li>&lt;p>Use select api on select.row module&lt;/p>
&lt;p> grid.select.row.selectById(rowId);
 grid.select.row.deSelectById(rowId);
 grid.select.row.isSelected(rowId);
 grid.select.row.getSelected();//[]
 grid.select.row.clear();&lt;/p>
&lt;/li>
&lt;/ol>
</example></examples></object></javascript>